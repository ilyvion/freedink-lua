--- d_canonical	2008-06-26 09:24:48.000000000 +0200
+++ d2_canonical	2008-06-29 19:45:03.000000000 +0200
@@ -22,7 +22,7 @@
 int check_if_move_is_legal (int u);
 void change_dir_to_diag (int *dir);
 int hurt_thing (int h, int damage, int special);
-int but_timer;
+int but_timer = 0;
 int water_timer;
 bool fire_forward;
 int fire_flip;
@@ -54,7 +54,11 @@
   int color = 0;
   if (spr[h].damage == -1)
     {
-      sprintf (crap, "%s", spr[h].text);
+//redink1 fix for : and '%deee bugs?
+
+      strcpy (crap, spr[h].text);
+//sprintf(crap, "%s", spr[h].text);
+
       cr = &crap[0];
       color = 14;
       while (cr[0] == '`')
@@ -198,10 +194,14 @@
       Msg ("Drew map.");
       if (mode > 2)
 	{
+	  fill_screen (0);
 	  draw_map_game_background ();
+	  if (*pupdate_status == 1)
+	    {
 	  draw_status_all ();
 	}
     }
+    }
   return ddrval;
 }				/* restoreAll */
 
@@ -352,7 +352,12 @@
       if (jinfo.dwYpos < 17000)
 	sjoy.up = TRUE;
     }
-pass:if (GetKeyboard (17))
+pass:
+//redink1 Only accept keyboard input when console is not active.
+
+  if (mConsoleActive == false)
+    {
+      if (GetKeyboard (17))
     sjoy.joybit[1] = TRUE;
   if (GetKeyboard (32))
     sjoy.joybit[2] = TRUE;
@@ -364,8 +369,11 @@
     sjoy.joybit[5] = TRUE;
   if (GetKeyboard (54))
     sjoy.joybit[6] = TRUE;
+      if (GetKeyboard (77))
+	sjoy.joybit[6] = TRUE;
   if (GetKeyboard (55))
     sjoy.joybit[7] = TRUE;
+    }
   for (int x5 = 1; x5 <= 10; x5++)
     sjoy.button[x5] = FALSE;
   for (int x = 1; x <= 10; x++)
@@ -379,6 +387,10 @@
 	    }
 	}
     }
+//redink1 Only accept keyboard input when console is not active.
+
+  if (mConsoleActive == false)
+    {
   if (GetKeyboard (39))
     sjoy.right = TRUE;
   if (GetKeyboard (37))
@@ -387,6 +399,7 @@
     sjoy.down = TRUE;
   if (GetKeyboard (38))
     sjoy.up = TRUE;
+    }
   for (int x2 = 1; x2 <= 10; x2++)
     {
       if (sjoy.joybit[x2])
@@ -659,6 +672,9 @@
 	    add_sprite (spr[h].x, spr[h].y, 5, spr[h].base_walk + 5, 1);
 	  spr[crap2].speed = 0;
 	  spr[crap2].seq = spr[h].base_walk + 5;
+//redink1 added this so corpses are the same size
+
+	  spr[crap2].size = spr[h].size;
 	  return;
 	}
       else
@@ -1566,11 +1686,14 @@
 int
 check_if_move_is_legal (int u)
 {
-  if (spr[u].move_active)
+//redink1 removed so move_nohard is active for all movements, not just active moves.
+
+//if (spr[u].move_active)
+
     if (spr[u].move_nohard == 1)
       return (0);
   if (u == 1)
-    if (in_this_base (spr[u].seq, 310))
+    if (in_this_base (spr[u].seq, mDinkBasePush))
       return (0);
   if (u == 1)
     if (!no_cheat)
@@ -2387,7 +2514,7 @@
   if (play.push_active)
     if (play.push_timer + 600 < thisTickCount)
       {
-	spr[h].seq = 310 + spr[h].dir;
+	spr[h].seq = mDinkBasePush + spr[h].dir;
 	spr[h].frame = 1;
 	spr[h].nocontrol = true;
 //play.push_active = false;
@@ -2399,6 +2526,15 @@
     {
       if (!run_through_tag_list_talk (h))
 	{
+//redink1 addition of 'not talking to anything' script
+
+	  int sc = load_script ("DNOTALK", 0, false);
+	  if (sc != 0 && locate (sc, "MAIN"))
+	    {
+	      run_script (sc);
+	    }
+	  else
+	    {
 	  kill_text_owned_by (h);
 	  int randy = (rand () % 6) + 1;
 #ifdef __GERMAN
@@ -2433,6 +2570,7 @@
 #endif
 	}
     }
+    }
   if ((sjoy.button[1] == TRUE) && (weapon_script != 0))
     {
       if (spr[h].base_hit > 0)
@@ -2448,7 +2586,11 @@
 
   if (but_timer < thisTickCount)
     {
-      for (x5 = 29; x5 < 256; x5++)
+//redink1 Only accept keyboard input when console is not active.
+
+      if (mConsoleActive == false)
+	{
+	  for (x5 = 29; x5 < 255; x5++)
 	{
 	  if (x5 == 32)
 	    x5++;
@@ -2480,15 +2622,42 @@
 	    }
 	}
     }
-  if ((sjoy.button[6] == TRUE)
-      || ((GetKeyboard (77)) && (but_timer < thisTickCount)))
+    }
+  if (sjoy.button[6] == TRUE)
     {
-      but_timer = thisTickCount + 200;
       int mycrap = load_script ("BUTTON6", 1, false);
       if (locate (mycrap, "MAIN"))
 	run_script (mycrap);
       goto b1end;
     }
+  if (sjoy.button[7] == TRUE)
+    {
+      int mycrap = load_script ("BUTTON7", 1, false);
+      if (locate (mycrap, "MAIN"))
+	run_script (mycrap);
+      goto b1end;
+    }
+  if (sjoy.button[8] == TRUE)
+    {
+      int mycrap = load_script ("BUTTON8", 1, false);
+      if (locate (mycrap, "MAIN"))
+	run_script (mycrap);
+      goto b1end;
+    }
+  if (sjoy.button[9] == TRUE)
+    {
+      int mycrap = load_script ("BUTTON9", 1, false);
+      if (locate (mycrap, "MAIN"))
+	run_script (mycrap);
+      goto b1end;
+    }
+  if (sjoy.button[10] == TRUE)
+    {
+      int mycrap = load_script ("BUTTON10", 1, false);
+      if (locate (mycrap, "MAIN"))
+	run_script (mycrap);
+      goto b1end;
+    }
   if (magic_script != 0)
     if (sjoy.joybit[3])
       goto shootm;
@@ -2496,10 +2665,21 @@
     {
       if (magic_script == 0)
 	{
+//redink1 addition of 'no magic' script
+
+	  int sc = load_script ("DNOMAGIC", 0, false);
+	  if (sc != 0 && locate (sc, "MAIN"))
+	    {
+	      run_script (sc);
+	    }
+	  else
+	    {
 	  int randy = (rand () % 6) + 1;
 	  kill_text_owned_by (h);
 #ifdef __GERMAN
-	  if (randy == 3)
+
+//if (randy == 3) 
+
 	    if (randy == 1)
 	      say_text
 		("`$Ich muß erst die Magie erlernen, bevor ich dies ausprobieren kann..",
@@ -2521,8 +2701,9 @@
 	  if (randy == 5)
 	    say_text ("`$Nothing happened.", h, 0);
 	  if (randy == 6)
 	    say_text ("`$Hocus pocus!", h, 0);
 #endif
+	    }
 	  goto b1end;
 	}
 //player pressed 1
@@ -2544,25 +2726,26 @@
     }
   if (sjoy.button[4])
     {
+//redink1 addition of 'enter key/inventory' script
+
+      int sc = load_script ("BUTTON4", 0, false);
+      if (sc != 0)
+	{
+	  if (locate (sc, "MAIN"))
+	    {
+	      run_script (sc);
+	      return;
+	    }
+	}
       item_screen = true;
       SoundPlayEffect (18, 22050, 0, 0, 0);
       return;
-    }
-  if (GetKeyboard (50))
-    {
-      if (!no_cheat)
-	{
+    }				/*if ( GetKeyboard(50) ) { if (!no_cheat) { 
 //player pressed 2
 
 //lets add a duck with brain 2
 
-	  crap = add_sprite (spr[h].x - 20, spr[h].y - 50, 3, 26, 1);
-	  spr[crap].speed = 1;
-	  spr[crap].base_walk = 20;
-	  spr[crap].exp = 11;
-	  spr[crap].hitpoints = 5;
-	}
-    }
+				   crap = add_sprite(spr[h].x-20,spr[h].y-50,3,26,1); spr[crap].speed = 1; spr[crap].base_walk = 20; spr[crap].exp = 11; spr[crap].hitpoints = 5; } } */
   if ((sjoy.button[5] == TRUE))
     {
       if (!showb.active)
@@ -2576,6 +2759,10 @@
 	      return;
 	    }
     }
+//redink1 Only accept keyboard input when console is not active.
+
+  if (mConsoleActive == false)
+    {
   if (GetKeyboard (66))
     {
       ResumeMidi ();
@@ -2584,6 +2771,7 @@
     {
       PauseMidi ();
     }
+    }
   if (spr[h].skip > 0)
     if (spr[h].skip <= spr[h].skiptimer)
       {
@@ -3109,6 +3297,14 @@
 void
 CyclePalette ()
 {
+//redink1 truecolor fadedown...
+
+  if (truecolor)
+    {
+      process_downcycle = true;
+    }
+  else
+    {
   int reg[15];
   int k;
   bool done_this_time = true;
@@ -3117,31 +3313,32 @@
       Msg ("error with getting entries");
       return;
     }
+      int lValue = (thisTickCount - lastTickCount) / 2;
   for (int kk = 1; kk < 256; kk++)
     {
       if (pe[kk].peBlue != 0)
 	{
 	  done_this_time = false;
-	  if (pe[kk].peBlue > 10)
-	    pe[kk].peBlue -= 10;
+	      if (pe[kk].peBlue > lValue)
+		pe[kk].peBlue -= lValue;
 	  else
-	    pe[kk].peBlue--;
+		pe[kk].peBlue = 0;
 	}
       if (pe[kk].peGreen != 0)
 	{
 	  done_this_time = false;
-	  if (pe[kk].peGreen > 10)
-	    pe[kk].peGreen -= 10;
+	      if (pe[kk].peGreen > lValue)
+		pe[kk].peGreen -= lValue;
 	  else
-	    pe[kk].peGreen--;
+		pe[kk].peGreen = 0;
 	}
       if (pe[kk].peRed != 0)
 	{
 	  done_this_time = false;
-	  if (pe[kk].peRed > 10)
-	    pe[kk].peRed -= 10;
+	      if (pe[kk].peRed > lValue)
+		pe[kk].peRed -= lValue;
 	  else
-	    pe[kk].peRed--;
+		pe[kk].peRed = 0;
 	}
     }
   lpDD->WaitForVerticalBlank (DDWAITVB_BLOCKBEGIN, NULL);
@@ -3163,13 +3360,21 @@
 	    }
 	}
     }
-} void
+}} void
 
 up_cycle (void)
 {
+//redink1 added this for true-color fade support
+
+  if (truecolor)
+    {
+      process_upcycle = true;
+    }
+  else
+    {
   bool donethistime = true;
   if (lpDDPal->GetEntries (0, 0, 256, pe) != DD_OK)
     {
       Msg ("error with getting entries");
       return;
     }
@@ -3224,7 +3431,7 @@
 	    run_script (junk);
 	  }
       }
-} void
+}} void
 
 draw_box (RECT box, int color)
 {
@@ -3235,6 +3442,117 @@
     lpDDSBack->Blt (&box, NULL, NULL, DDBLT_COLORFILL | DDBLT_WAIT, &ddbltfx);
 }
 
+//redink1 added for true-color fade...
+
+WORD
+GetMaskPos (DWORD dwMask)
+{
+  WORD wPos = 0;
+  while (!(dwMask & (1 << wPos)))
+    wPos++;
+  return wPos;
+}
+
+//redink1 added for true-color fade...
+
+WORD
+GetNumberOfBits (DWORD dwMask)
+{
+  WORD wBits = 0;
+  while (dwMask)
+    {
+      dwMask = dwMask & (dwMask - 1);
+      wBits++;
+    }
+  return wBits;
+}
+
+//redink1 added for true-color fade...
+
+DDSURFACEDESC sdBack;
+void
+ApplyFade16 (unsigned short aValue, unsigned short *aBuffer,
+	     unsigned int aPitch)
+{
+  unsigned int lJump (aPitch - 640 * 2);
+  for (unsigned short lYCoordinate (0); lYCoordinate < 480; lYCoordinate++)
+    {
+      for (unsigned short lXCoordinate (0); lXCoordinate < 640;
+	   lXCoordinate++)
+	{
+	  *aBuffer = m16BitFadeValues[*aBuffer][aValue];
+	  aBuffer += 1;
+	} aBuffer += lJump;
+    } return;
+}
+
+void
+ApplyFade24 (unsigned char aValue, unsigned char *aBuffer,
+	     unsigned int aPitch)
+{
+  unsigned int lJump (aPitch - 640 * 3);
+  for (unsigned short lYCoordinate (0); lYCoordinate < 480; lYCoordinate++)
+    {
+      for (unsigned short lXCoordinate (0); lXCoordinate < 640;
+	   lXCoordinate++)
+	{
+	  if (*((DWORD *) aBuffer) != 0xFFFFFF)
+	    {
+	      *aBuffer = m8BitFadeValues[*aBuffer][aValue];
+	      aBuffer += 1;
+	      *aBuffer = m8BitFadeValues[*aBuffer][aValue];
+	      aBuffer += 1;
+	      *aBuffer = m8BitFadeValues[*aBuffer][aValue];
+	      aBuffer += 1;
+	    }
+	  else
+	    {
+	      aBuffer += 3;
+	    }
+	}
+      aBuffer += lJump;
+    }
+  return;
+}
+
+void
+ApplyFade32 (register unsigned char aValue, register unsigned char *aBuffer,
+	     unsigned int aPitch)
+{
+  unsigned int lJump (aPitch - 640 * 4);
+  for (register unsigned short lYCoordinate (0); lYCoordinate < 480;
+       lYCoordinate++)
+    {
+      for (register unsigned short lXCoordinate (0); lXCoordinate < 640;
+	   lXCoordinate++)
+	{
+	  if (*((DWORD *) aBuffer) != 0xFFFFFF)
+	    {
+// Blue
+
+	      *aBuffer = m8BitFadeValues[*aBuffer][aValue];
+	      aBuffer += 1;
+// Green
+
+	      *aBuffer = m8BitFadeValues[*aBuffer][aValue];
+	      aBuffer += 1;
+// Red
+
+	      *aBuffer = m8BitFadeValues[*aBuffer][aValue];
+	      aBuffer += 2;
+	    }
+	  else
+	    {
+	      aBuffer += 4;
+	    }
+	}
+      aBuffer += lJump;
+    }
+  return;
+}
+
+//redink1 and Invertigo fix for windowed/high color mode
+
 void
 flip_it (void)
 {
@@ -3242,6 +3560,134 @@
   RECT rcRectSrc;
   RECT rcRectDest;
   POINT p;			/*int timer = GetTickCount() + 50; while(GetTickCount() < timer) { } */
+//redink1 fix for true-color transition
+
+//The idea is to apply the fade to the backbuffer right before the main flip/blt.
+
+  if (truecolor && (process_downcycle || process_upcycle || bFadedDown))
+    {
+      RECT r;
+      r.bottom = 480;
+      r.left = 0;
+      r.right = 640;
+      r.top = 0;
+//Make sure we're not 'stuck'... i.e. fade down when already black, or fade up when not black
+
+      if (process_downcycle && bFadedDown || process_upcycle && !bFadedDown)
+	{
+	  if (process_downcycle)
+	    process_downcycle = false;
+	  if (process_upcycle)
+	    {
+	      process_upcycle = false;
+	      if (mSwapped)
+		{
+// if ( windowed )
+
+// {
+
+		  lpDDSFade->BltFast (0, 0, lpDDSBack, &r,
+				      DDBLTFAST_NOCOLORKEY | DDBLTFAST_WAIT);
+		  LPDIRECTDRAWSURFACE lTemp;
+		  lTemp = lpDDSBack;
+		  lpDDSBack = lpDDSFade;
+		  lpDDSFade = lTemp;	/* } else { DDSURFACEDESC ddsd; lpDDSBack->GetSurfaceDesc( &ddsd ); ddsd.ddsCaps.dwCaps = DDSCAPS_BACKBUFFER; LPDIRECTDRAWSURFACE lTemp; ddrval = lpDDSPrimary->GetAttachedSurface( &ddsd.ddsCaps, &lTemp ); lTemp->BltFast( 0, 0, lpDDSBack, &r, DDBLTFAST_NOCOLORKEY | DDBLTFAST_WAIT); lpDDSBack->Release(); lpDDSBack = lTemp; } */
+		  mSwapped = false;
+		}
+	    }
+	  if (cycle_script != 0)
+	    {
+	      int junk = cycle_script;
+	      cycle_script = 0;
+	      run_script (junk);
+	    }
+	}
+      if (process_downcycle || bFadedDown || process_upcycle)
+	{
+	  if (mSwapped == false)
+	    {
+// if ( windowed )
+
+// {
+
+	      lpDDSFade->BltFast (0, 0, lpDDSBack, &r,
+				  DDBLTFAST_NOCOLORKEY | DDBLTFAST_WAIT);
+	      LPDIRECTDRAWSURFACE lTemp;
+	      lTemp = lpDDSBack;
+	      lpDDSBack = lpDDSFade;
+	      lpDDSFade = lTemp;	/* } else { DDSURFACEDESC ddsd; lpDDSBack->GetSurfaceDesc( &ddsd ); ddsd.ddsCaps.dwCaps = DDSCAPS_BACKBUFFER | DDSCAPS_SYSTEMMEMORY; lpDDSBack->Release(); LPDIRECTDRAWSURFACE lTemp; ddrval = lpDDSPrimary->GetAttachedSurface( &ddsd.ddsCaps, &lTemp ); lTemp->BltFast( 0, 0, lpDDSBack, &r, DDBLTFAST_NOCOLORKEY | DDBLTFAST_WAIT); lpDDSBack->Release(); lpDDSBack = lTemp; } */
+	      mSwapped = true;
+	    }
+	  unsigned char lFadeValue =
+	    static_cast <
+	    unsigned char >(30.0f *
+			    (static_cast <
+			     float >(iTrueColorFadeTime) / 400.0f));
+	  if (lFadeValue >= 30)
+	    {
+	      iTrueColorFadeTime = 0;
+	      if (process_downcycle == true)
+		{
+		  bFadedDown = true;
+		}
+	      else if (process_upcycle == true)
+		{
+		  bFadedDown = false;
+		}
+	      lFadeValue = 29;
+	    }
+	  if (process_upcycle == true)
+	    {
+	      lFadeValue = 29 - lFadeValue;
+	    }
+	  else if (bFadedDown == true)
+	    {
+	      lFadeValue = 29;
+	    }
+//Setup surface description data-structure
+
+	  memset (&sdBack, 0, sizeof (DDSURFACEDESC));
+	  sdBack.dwSize = sizeof (DDSURFACEDESC);
+//Lock our surfaces
+
+	  lpDDSBack->Lock (NULL, &sdBack, DDLOCK_DONOTWAIT, NULL);
+//Copy backbuffer to fade surface
+
+// HRESULT h = lpDDSFade->BltFast( 0, 0, lpDDSBack, &r, DDBLTFAST_NOCOLORKEY | DDBLTFAST_WAIT);
+
+//Lock our surfaces
+
+// lpDDSFade->Lock(NULL, &sdBack, DDLOCK_WAIT | DDLOCK_NOSYSLOCK, NULL);
+
+	  if (mColorDepth == ColorDepth16Bit_565
+	      || mColorDepth == ColorDepth16Bit_555)
+	    {
+	      unsigned short *lBuffer = (unsigned short *) sdBack.lpSurface;
+	      ApplyFade16 (lFadeValue, lBuffer, sdBack.lPitch);
+	    }
+	  else if (mColorDepth == ColorDepth24Bit)
+	    {
+	      unsigned char *lBuffer = (unsigned char *) sdBack.lpSurface;
+	      ApplyFade24 (lFadeValue, lBuffer, sdBack.lPitch);
+	    }
+	  else if (mColorDepth == ColorDepth32Bit)
+	    {
+	      unsigned char *lBuffer = (unsigned char *) sdBack.lpSurface;
+	      ApplyFade32 (lFadeValue, lBuffer, sdBack.lPitch);
+	    }
+	  iTrueColorFadeTime += fps_final;
+	  lpDDSBack->Unlock (NULL);
+	  if (!windowed)
+	    {
+	      lpDDSFade->BltFast (0, 0, lpDDSBack, &r,
+				  DDBLTFAST_NOCOLORKEY | DDBLTFAST_WAIT);
+	    }
+// lpDDSFade->Unlock( NULL );
+
+// h = lpDDSBack->BltFast( 0, 0, lpDDSFade, &r, DDBLTFAST_NOCOLORKEY | DDBLTFAST_WAIT);
+
+	}
+    }
   if (!windowed)
     {
       while (1)
@@ -3280,6 +3726,7 @@
       SetRect (&rcRectSrc, 0, 0, 640, 480);
       ddbltfx.dwSize = sizeof (ddbltfx);
       ddbltfx.dwDDFX = DDBLTFX_NOTEARING;
+      lpDD->WaitForVerticalBlank (DDWAITVB_BLOCKBEGIN, NULL);
       ddrval =
 	lpDDSPrimary->Blt (&rcRectDest, lpDDSBack, &rcRectSrc,
 			   DDBLT_DDFX | DDBLT_WAIT, &ddbltfx);
@@ -3358,6 +3805,9 @@
 		draw_box (box, 33);
 	      if (inside_box (spr[h].x, spr[h].y, box))
 		{
+//redink1 addition for fixing missle_source problems
+
+		  *pmissle_source = h;
 		  if (spr[i].nohit == 1)
 		    {
 		      if (spr[i].script > 0)
@@ -3524,8 +3974,9 @@
   if (spr[sprite].seq == 0)
     {
       process_count++;
+      if (!truecolor || truecolor && process_count == 1)	//redink1 Limit palette cycles for true color mode
       CyclePalette ();
-      if (process_count > 5)
+      if (process_count > 5 && !truecolor || truecolor && process_downcycle == false)	//redink1 more limits for fade down stuff
 	{
 	  ddbltfx.dwSize = sizeof (ddbltfx);
 	  ddbltfx.dwFillColor = 0;
@@ -3540,6 +3991,10 @@
 	  spr[1].x = pam.sprite[block].warp_x;
 	  spr[1].y = pam.sprite[block].warp_y;
 	  *pmap = pam.sprite[block].warp_map;
+//redink1 change so map indicator is correct on warp.
+
+	  if (map.indoor[pam.sprite[block].warp_map] == 0)
+	    play.last_map = pam.sprite[block].warp_map;
 	  load_map (map.loc[pam.sprite[block].warp_map]);
 	  draw_map_game ();
 	  process_upcycle = true;
@@ -4446,20 +4893,19 @@
     {
 //let's display a nice dot to mark where they are on the map
 
-      int x = play.last_map;
+      int x = play.last_map - 1;
       int mseq = 165;
       showb.picframe++;
       if (showb.picframe > index[mseq].last)
 	showb.picframe = 1;
       int mframe = showb.picframe;
-      lpDDSBack->BltFast (((x) * 20 - ((x / 32) * 640)) - 20, (x / 32) * 20,
+      lpDDSBack->BltFast ((x % 32) * 20, (x / 32) * 20,
 			  k[seq[mseq].frame[mframe]].k,
 			  &k[seq[mseq].frame[mframe]].box,
 			  DDBLTFAST_SRCCOLORKEY | DDBLTFAST_WAIT);
     }
   if ((sjoy.button[1]) || (sjoy.button[2]) || (sjoy.button[3])
-      || (sjoy.button[4]) || (sjoy.button[5]) || (sjoy.button[6])
-      || ((GetKeyboard (77)) && (but_timer < thisTickCount)))
+      || (sjoy.button[4]) || (sjoy.button[5]) || (sjoy.button[6]))
     {
       showb.active = false;
       if (showb.script != 0)
@@ -4601,7 +5047,10 @@
       bActive = wParam;
       break;
     case WM_SETCURSOR:
+      if (!windowed)
+	{
       SetCursor (NULL);
+	}
       return TRUE;
     case WM_CREATE:
       break;
@@ -4610,22 +5059,115 @@
       PostQuitMessage (0);
       break;
     case WM_KEYDOWN:
+      if (mConsoleActive)
+	{
       switch (wParam)
 	{			/*case VK_F1: { Msg("F1 pressed"); 
 				   //g_pMouse->Unacquire();
 
 	     int crap; } break; case VK_F3: { fill_whole_hard(); fill_hard_sprites(); fill_back_sprites(); } break; *//*case VK_F4: { process_downcycle = true; cycle_clock = thisTickCount; } */
+	    case VK_UP:
+	      if (mConsoleHistoryIndex > 0)
+		{
+		  mConsoleHistoryIndex -= 1;
+		  mConsoleLine = mConsoleLineHistory[mConsoleHistoryIndex];
+		}
 	  break;
+	    case VK_DOWN:
+	      mConsoleHistoryIndex += 1;
+	      if (mConsoleHistoryIndex < mConsoleLineHistory.size ())
+		{
+		  mConsoleLine = mConsoleLineHistory[mConsoleHistoryIndex];
+		}
+	      else
+		{
+		  mConsoleHistoryIndex = mConsoleLineHistory.size ();
+		  mConsoleLine = "";
 	}
       break;
-// case WM_DESTROY:
-
-// finiObjects();
+	    default:
+	      break;
+	    }
+	}
+      break;
+// redink1 addition of console
 
-// PostQuitMessage( 0 );
+    case WM_CHAR:
+      if (mConsoleActive)
+	{
+	  switch (wParam)
+	    {
+	    case 0x08:		// Process a backspace.
+	      if (mConsoleLine.length () > 0)
+		{
+		  mConsoleLine =
+		    mConsoleLine.substr (0, mConsoleLine.length () - 1);
+		}
+	      break;
+	    case 0x0A:		// Process a linefeed
+	      break;
+	    case 0x1B:		// Process an escape. 
+	      mConsoleActive = false;
+	      mConsoleLine = "";
+	      break;
+	    case 0x09:		// Process a tab. 
+	      break;
+	    case 0x0D:		// Process a carriage return, try to parse the string.
+	      if (mConsoleScript == 0 || rbuf[mConsoleScript] == NULL)
+		{
+		  mConsoleScript = 0;
+		  for (int k = 1; k < max_scripts; k++)
+		    {
+		      if (rbuf[k] == NULL)
+			{
+			  mConsoleScript = k;
+			  rinfo[mConsoleScript] =
+			    (struct refinfo *)
+			    malloc (sizeof (struct refinfo));
+			  memset (rinfo[mConsoleScript], 0,
+				  sizeof (struct refinfo));
+			  rinfo[mConsoleScript]->sprite = 1000;
+			  rinfo[mConsoleScript]->level = 1;
+			  rbuf[mConsoleScript] = (char *) malloc (255);
+			  break;
+			}
+		    }
+		}
+	      if (mConsoleScript != 0)
+		{
+		  strncpy (rbuf[mConsoleScript], mConsoleLine.c_str (), 254);
+		  process_line (mConsoleScript, rbuf[mConsoleScript], false);
+		  mConsoleReturnValue = returnint;
+		  mConsoleLineHistory.push_back (mConsoleLine);
+		  if (mConsoleLineHistory.size () > 20)
+		    {
+		      mConsoleLineHistory.erase (mConsoleLineHistory.
+						 begin ());
+		    }
+		  mConsoleHistoryIndex = mConsoleLineHistory.size ();
+		}
+	      mConsoleLine = "";
+	      break;
+	    default:		// Process displayable characters.
+	      mConsoleLine += static_cast < char >(wParam);
+	      break;
+	    }
+// clear keyboard buffer
 
-// break;
+	  for (int x = 0; x < 256; x++)
+	    {
+	      if (GetKeyboard (x))
+		{
+		}
+	    }
+	}
+      break;
+//redink1 and Invertigo fix for Alt-F4/X button exiting problem
 
+    case WM_CLOSE:
+      finiObjects ();
+      PostQuitMessage (0);
+      break;
     }
 //cycle through keys
 
@@ -4693,9 +5235,12 @@
   program_idata ();
 }
 
+//redink1 and Invertigo fix for windowed/high color mode
+
 bool
 check_arg (char crap[255])
 {
+  truecolor = false;
   char shit[200];
 // strupr(crap);
 
@@ -4706,7 +5251,17 @@
       if (strnicmp (shit, "-window", strlen ("-window")) == 0)
 	{
 	  windowed = true;
-	  no_transition = true;
+	  truecolor = true;
+// no_transition = true; 
+
+	}
+      if (strnicmp (shit, "-dinkpal", strlen ("-dinkpal")) == 0)
+	{
+	  dinkpal = true;
+	}
+      if (strnicmp (shit, "-truecolor", strlen ("-truecolor")) == 0)
+	{
+	  truecolor = true;
 	}
       if (strnicmp (shit, "-debug", strlen ("-debug")) == 0)
 	{
@@ -4715,7 +5270,7 @@
 	}
       if (strnicmp (shit, "-nojoy", strlen ("-nojoy")) == 0)
 	{
-	  joystick = false;
+	  disablejoystick = TRUE;
 	}
       if (strnicmp (shit, "-noini", strlen ("-noini")) == 0)
 	{
@@ -4758,11 +5318,13 @@
   Msg ("Dir is now %s.", dir);
   return (true);
 }				/* * doInit - do work required for every instance of the application: * create the window, initialize data */
 
+//redink1 and invertigo fix for windowed/high color mode
+
 static BOOL
 doInit (HINSTANCE hInstance, int nCmdShow)
 {
-  HWND hwnd;
+  memset (id, '\0', sizeof (id));
 // HRESULT dsrval;
 
 // BOOL bUseDSound;
@@ -4803,11 +5366,21 @@
 
     }
   if (windowed)
-    {
+    {				/*hwnd = CreateWindowEx( 0, NAME, TITLE, 
+				   // WS_POPUP,
+
+				   WS_SYSMENU|WS_CAPTION, 0, 0, 640, 480, 
+				   //GetSystemMetrics(SM_CXSCREEN),
+
+				   //GetSystemMetrics(SM_CYSCREEN),
+
+				   NULL, NULL, hInstance, NULL ); if( !hwnd ) { return FALSE; } 
+				   // Now check actual size of client area
+
+				   RECT check; GetClientRect(hwnd, &check); int ExtendWidth = 640 - (check.right - check.left); int ExtendHeight = 480 - (check.bottom - check.top); DestroyWindow(hwnd); */
       hwnd = CreateWindowEx (0, NAME, TITLE,
 // WS_POPUP,
-			     WS_SYSMENU | WS_CAPTION, 0, 0, 640 + winoffsetx,
-			     480 + winoffset,
+			     WS_SYSMENU | WS_CAPTION, 0, 0, 640, 480,
 // GetSystemMetrics(SM_CXSCREEN),
 // GetSystemMetrics(SM_CYSCREEN),
 			     NULL, NULL, hInstance, NULL);
@@ -4924,17 +5505,39 @@
 	{
 	  return initFail (hwnd, "SetCooperative level failed.");
 	}
-// Set the video mode to 640x480x8
+// Set the video mode to 640x480xX
 
-      ddrval = lpDD->SetDisplayMode (x, y, 8);
-// finiObjects(); 
-
-// return false;
+      if (truecolor == true)
+	{
+// Keep trying until one works, or not. There should be a way to see what DirectX supports... hrm
 
+	  ddrval = lpDD->SetDisplayMode (x, y, 32);
+	  if (ddrval != DD_OK)
+	    {
+	      ddrval = lpDD->SetDisplayMode (x, y, 24);
+	      if (ddrval != DD_OK)
+		{
+		  ddrval = lpDD->SetDisplayMode (x, y, 16);
+		  if (ddrval != DD_OK)
+		    {
+		      return initFail (hwnd,
+				       "640 X 480, true color mode not supported.");
+		    }
+		}
+	    }
+	}
+      else
+	{
+	  ddrval = lpDD->SetDisplayMode (x, y, 8);
       if (ddrval != DD_OK)
 	{
 	  return initFail (hwnd, "640 X 480, 8 bit not supported.");
 	}
+	}
+// finiObjects(); 
+
+// return false;
+
       ZeroMemory (&hm, sizeof (hit_map));
 // Create the primary surface with 1 back buffer
 
@@ -4955,6 +5558,146 @@
 	  return initFail (hwnd, "Could not create backbuffer,");
 	}
     }
+//redink1 init for color depth information
+
+  if (truecolor)
+    {
+      DDSURFACEDESC dds;
+      memset (&dds, 0, sizeof (DDSURFACEDESC));
+      dds.dwSize = sizeof (DDSURFACEDESC);
+      lpDDSBack->GetSurfaceDesc (&dds);
+      if (dds.ddpfPixelFormat.dwGBitMask == 0x07E0)
+	{
+// 565
+
+	  mColorDepth = ColorDepth16Bit_565;
+	  m16BitFadeValues = new unsigned short[65536][30];
+	  for (unsigned short lFade (0); lFade < 30; lFade++)
+	    {
+	      float lFadeAdjustment ((30.0f - static_cast < float >(lFade))
+				     /30.0f);
+	      for (unsigned short lRed (0); lRed < 32; lRed++)
+		{
+		  unsigned short lRedFadeValue =
+		    static_cast < unsigned short >(static_cast <
+						   float >(lRed) *
+						   lFadeAdjustment) <<11;
+		  for (unsigned short lGreen (0); lGreen < 64; lGreen++)
+		    {
+		      unsigned short lGreenFadeValue =
+			static_cast < unsigned short >(static_cast <
+						       float >(lGreen) *
+						       lFadeAdjustment) <<5;
+		      for (unsigned short lBlue (0); lBlue < 32; lBlue++)
+			{
+			  unsigned short lBlueFadeValue =
+			    static_cast < unsigned short >(static_cast <
+							   float >(lBlue) *
+							   lFadeAdjustment);
+			  if ((lRed << 11 | lGreen << 5 | lBlue) == 0xFFFF)
+			    {
+			      lRedFadeValue = lRed << 11;
+			      lGreenFadeValue = lGreen << 5;
+			      lBlueFadeValue = lBlue;
+			    }
+			  m16BitFadeValues[lRed << 11 | lGreen << 5 |
+					   lBlue][lFade] =
+			    lRedFadeValue | lGreenFadeValue | lBlueFadeValue;
+			}
+		    }
+		}
+	    }
+	}
+      else if (dds.ddpfPixelFormat.dwGBitMask == 0x03E0)
+	{
+// 555
+
+	  mColorDepth = ColorDepth16Bit_555;
+	  m16BitFadeValues = new unsigned short[65536][30];
+	  for (unsigned short lFade (0); lFade < 30; lFade++)
+	    {
+	      float lFadeAdjustment ((30.0f - static_cast < float >(lFade))
+				     /30.0f);
+	      for (unsigned short lRed (0); lRed < 32; lRed++)
+		{
+		  unsigned short lRedFadeValue =
+		    static_cast < unsigned short >(static_cast <
+						   float >(lRed) *
+						   lFadeAdjustment) <<10;
+		  for (unsigned short lGreen (0); lGreen < 32; lGreen++)
+		    {
+		      unsigned short lGreenFadeValue =
+			static_cast < unsigned short >(static_cast <
+						       float >(lGreen) *
+						       lFadeAdjustment) <<5;
+		      for (unsigned short lBlue (0); lBlue < 32; lBlue++)
+			{
+			  unsigned short lBlueFadeValue =
+			    static_cast < unsigned short >(static_cast <
+							   float >(lBlue) *
+							   lFadeAdjustment);
+			  if ((lRed << 10 | lGreen << 5 | lBlue) == 0xFFFF)
+			    {
+			      lRedFadeValue = lRed << 10;
+			      lGreenFadeValue = lGreen << 5;
+			      lBlueFadeValue = lBlue;
+			    }
+			  m16BitFadeValues[lRed << 10 | lGreen << 5 |
+					   lBlue][lFade] =
+			    lRedFadeValue | lGreenFadeValue | lBlueFadeValue;
+			}
+		    }
+		}
+	    }
+	}
+      else if (dds.ddpfPixelFormat.dwRGBBitCount == 32
+	       || dds.ddpfPixelFormat.dwRGBBitCount == 24)
+	{
+// 32 & 24
+
+	  if (dds.ddpfPixelFormat.dwRGBBitCount == 32)
+	    {
+	      mColorDepth = ColorDepth32Bit;
+	    }
+	  else
+	    {
+	      mColorDepth = ColorDepth24Bit;
+	    }
+	  m8BitFadeValues = new unsigned char[256][30];
+	  for (unsigned char lFade (0); lFade < 30; lFade++)
+	    {
+	      double lFadeAdjustment ((30.0 - static_cast < double >(lFade))
+				      /30.0);
+	      for (unsigned short lValue (0); lValue <= 255; lValue++)
+		{
+		  m8BitFadeValues[lValue][lFade] =
+		    static_cast < unsigned char >(static_cast <
+						  double >(lValue) *
+						  lFadeAdjustment);
+	}}}
+      else
+	{
+	  mColorDepth = ColorDepthNotRecognized;
+// No fade
+
+	}
+      dwRMask = dds.ddpfPixelFormat.dwRBitMask;
+      dwGMask = dds.ddpfPixelFormat.dwGBitMask;
+      dwBMask = dds.ddpfPixelFormat.dwBBitMask;
+      wRBits = GetNumberOfBits (dwRMask);
+      wGBits = GetNumberOfBits (dwGMask);
+      wBBits = GetNumberOfBits (dwBMask);
+      wRPos = GetMaskPos (dwRMask);
+      wGPos = GetMaskPos (dwGMask);
+      wBPos = GetMaskPos (dwBMask);
+      memset (&ddsd, 0, sizeof (ddsd));
+      ddsd.dwSize = sizeof (ddsd);
+      ddsd.dwFlags = DDSD_CAPS | DDSD_HEIGHT | DDSD_WIDTH;
+      ddsd.ddsCaps.dwCaps = DDSCAPS_BACKBUFFER | DDSCAPS_SYSTEMMEMORY;
+      ddsd.dwWidth = 640;
+      ddsd.dwHeight = 480;
+      ddrval = lpDD->CreateSurface (&ddsd, &lpDDSFade, NULL);
+    }
 //init is finished, now lets load some more junk
 
 //return initFail(hwnd, "Couldn't make a Clipper object, god knows why.");
@@ -4973,6 +5716,12 @@
     {
       Msg ("error with getting entries in beginning");
     }
+//redink1 Faster true-color fades
+
+  /*if ( truecolor ) { 
+     // mPrecalculatedFadeValues = new std::map<DWORD, FadeValues>;
+
+     DWORD dwWhite = dwRMask | dwGMask | dwBMask; PALETTEENTRY lPaletteEntries[256]; lpDDPal->GetEntries( 0, 0, 256, lPaletteEntries ); for ( int lPaletteEntry = 0; lPaletteEntry < 256; lPaletteEntry++ ) { DWORD lColor = ( lPaletteEntries[lPaletteEntry].peRed >> (8 - wRBits) << wRPos | lPaletteEntries[lPaletteEntry].peGreen >> (8 - wGBits) << wGPos | lPaletteEntries[lPaletteEntry].peBlue >> (8 - wBBits) << wBPos ); mPrecalculatedFadeValues->[lColor].reserve(256); for ( int lFadeValue = 0; lFadeValue < 256; lFadeValue += 1 ) { DWORD red = (lColor & dwRMask) << (8 - wRBits) >> wRPos; red = (red >= lFadeValue ? red - lFadeValue : 0); DWORD green = (lColor & dwGMask) << (8 - wGBits) >> wGPos; green = (green >= lFadeValue ? green - lFadeValue : 0); DWORD blue = (lColor & dwBMask) << (8 - wBBits) >> wBPos; blue = (blue >= lFadeValue ? blue - lFadeValue : 0); DWORD lResult = ( red >> (8 - wRBits) << wRPos | green >> (8 - wGBits) << wGPos | blue >> (8 - wBBits) << wBPos ); mPrecalculatedFadeValues[lColor].push_back( lResult ); } } } */
   if (exist ("tiles\\splash.bmp"))
     lpDDPal = DDLoadPalette (lpDD, "tiles\\SPLASH.BMP");
   else
@@ -5029,6 +5778,8 @@
   if (cd_inserted)
     PlayCD (g_hWnd, 7);
 #endif
+  if (disablejoystick == FALSE)
+    {
   if (CheckJoyStickPresent () == FALSE)
     {
 // return initFail(hwnd, "Could not init the joystick.");
@@ -5039,6 +5790,7 @@
     {
       joystick = TRUE;
     }
+    }
   rcRect.left = 0;
   rcRect.top = 0;
   rcRect.right = x;
@@ -5158,6 +5910,8 @@
   attach ();
 //init_mouse(hwnd);
 
+  memset (&spr, NULL, sizeof (spr));
@@ -5346,6 +6100,7 @@
 	{
 	  if (g_b_kill_app == false)
 	    {
+	      SetFocus (hwnd);
 	      updateFrame ();
 	    }
 //WaitMessage();
@@ -5355,6 +6110,8 @@
 	{
 // make sure we go to sleep if we have nothing else to do
 
+	  Sleep (1);
+	  SetFocus (NULL);
 	  WaitMessage ();
 	}
     }
