--- dv_canonical	2008-06-26 09:24:25.000000000 +0200
+++ dv2_canonical	2008-06-29 19:45:08.000000000 +0200
@@ -32,7 +32,11 @@
 //#include "midi.h"
 
 #include <fcntl.h>
 #include <malloc.h>
+
+//redink1 moves this here so could ignore keystrokes
+
+HWND hwnd;
 void check_midi (void);
 UINT midi_id;
 
@@ -49,0 +68,0 @@
[...]
+//redink1 added for console
+
+bool mConsoleActive = false;
+//std::string mConsoleLine;
+
+unsigned int mConsoleScript = 0;
+//std::vector<std::string> mConsoleLineHistory;
+
+unsigned short int mConsoleHistoryIndex = 0;
+unsigned int mConsoleReturnValue = 0;
 void init_scripts (void);
 int load_script (char filename[15], int sprite, bool set_sprite);
 void strchar (char *string, char ch);
@@ -64,7 +147,8 @@
 DWORD killcd (HWND hWndNotify, BYTE bTrack);
 void update_status_all (void);
 int add_sprite (int x1, int y, int brain, int pseq, int pframe);
-void add_exp (int num, int h);
+void load_info ();		//redink1
+void add_exp (int num, int h, bool addEvenIfNotLastSpriteHit = false);
 bool locate (int script, char proc[20]);
 bool exist (char name[255]);
 BOOL SoundStopEffect (int sound);
@@ -420,10 +543,12 @@
   int nodraw;
   int frame_delay;
   int picfreeze;
 //redink1
 
   int bloodseq;
   int bloodnum;
+// std::map<std::string, int>* custom;
+
 };
 struct seth_joy
 {
@@ -635,7 +765,8 @@
 BYTE torusColors[256];		// Marks the colors used in the torus
 HWND hWndMain = NULL;
 JOYINFOEX jinfo;		//joystick info
-BOOL joystick = false;
+BOOL joystick = FALSE;
+BOOL disablejoystick = FALSE;
 hardness hmap;
 RECT tilerect[tile_screens];
 void
@@ -1940,10 +2089,15 @@
 	  hm.x[x1].y[y1] = get_hard_map (0, x1, y1);
 }}} void
 
-add_exp (int num, int h)
+add_exp (int num, int h, bool addEvenIfNotLastSpriteHit)
+{
+//redink1 fix - made work with all sprites when using add_exp DinkC command
+
+  if (addEvenIfNotLastSpriteHit == false)
 {
   if (spr[h].last_hit != 1)
     return;
+    }
   if (num > 0)
     {
 //add experience
@@ -2149,6 +2311,7 @@
     Msg ("ERROR: Couldn't read map %d?!?", num);
   fclose (fp);
   spr[1].move_active = false;
+  spr[1].move_nohard = false;
   spr[1].freeze = false;
   screenlock = 0;
   fill_whole_hard ();
@@ -2443,6 +2677,11 @@
       Msg ("Loaded map.");
       draw_map_game ();
       Msg ("Map drawn.");
+//redink1 fixes
+
+      fexp = *pexper;
+      draw_status_all ();
+      Msg ("Status drawn.");
       last_saved_game = num;
       return (true);
     }
@@ -3976,7 +4359,14 @@
   if (ddrval == DDERR_WASSTILLDRAWING)
     goto again3;
   fraise = next_raise ();
+  if (*pexper < fraise)
+    {
   fexp = *pexper;
+    }
+  else
+    {
+      fexp = fraise - 1;
+    }
   fstrength = *pstrength;
   fmagic = *pmagic;
   fgold = *pgold;
@@ -3992,10 +4382,10 @@
   draw_icons ();
   if (*pmagic_cost > 0)
     if (*pmagic_level > 0)
-      draw_mlevel (*pmagic_level / (*pmagic_cost / 100));
-}
+      draw_mlevel (*pmagic_level / static_cast <
+		   double >(*pmagic_cost) / 100.0);
+} bool
 
-bool
 inside_box (int x1, int y1, RECT box)
 {
   if (x1 > box.right)
@@ -4054,6 +4444,15 @@
 	  spr[x].strength = 0;
 	  spr[x].damage = 0;
 	  spr[x].defense = 0;
+	  if (spr[x].custom == NULL)
+	    {
+// spr[x].custom = new std::map<std::string, int>;
+
+	    }
+	  else
+	    {
+	      spr[x].custom->clear ();
+	    }
 	  return (x);
 	}
     }
@@ -4117,6 +4520,24 @@
 							  0) | (spr[h].alt.
 								right != 0))
     {
+//redink1 checks for correct box stuff
+
+      if (spr[h].alt.left < 0)
+	spr[h].alt.left = 0;
+      if (spr[h].alt.left > k[getpic (h)].box.right)
+	spr[h].alt.left = k[getpic (h)].box.right;
+      if (spr[h].alt.top < 0)
+	spr[h].alt.top = 0;
+      if (spr[h].alt.top > k[getpic (h)].box.bottom)
+	spr[h].alt.top = k[getpic (h)].box.bottom;
+      if (spr[h].alt.right < 0)
+	spr[h].alt.right = 0;
+      if (spr[h].alt.right > k[getpic (h)].box.right)
+	spr[h].alt.right = k[getpic (h)].box.right;
+      if (spr[h].alt.bottom < 0)
+	spr[h].alt.bottom = 0;
+      if (spr[h].alt.bottom > k[getpic (h)].box.bottom)
+	spr[h].alt.bottom = k[getpic (h)].box.bottom;
 //spr[h].alt.bottom = 10; 
 
       box_crap->left = box_crap->left + spr[h].alt.left;
@@ -4651,6 +5072,7 @@
 	      if (rinfo[script]->sprite != 1000)
 		{
 		  spr[rinfo[script]->sprite].move_active = false;
+		  spr[rinfo[script]->sprite].move_nohard = false;
 		}
 	      rinfo[script]->skipnext = false;
 	      rinfo[script]->onlevel = 0;
@@ -4728,29 +5202,142 @@
     }
 }
 
@@ -4802,6 +5391,7 @@
 bool
 get_parms (char proc_name[20], int script, char *h, int p[10])
 {
+  memset (nlist, 0, 10 * sizeof (int));
   char crap[100];
   strip_beginning_spaces (h);
   if (h[0] == '(')
@@ -4954,6 +5544,15 @@
 	  spr[x].damage = 0;
 	  spr[x].defense = 0;
 	  spr[x].hard = 1;
+	  if (spr[x].custom == NULL)
+	    {
+// spr[x].custom = new std::map<std::string, int>;
+
+	    }
+	  else
+	    {
+	      spr[x].custom->clear ();
+	    }
 	  return (x);
 	}
     }
@@ -5016,8 +5615,11 @@
 
 //Msg("Sprite %d's seq is %d",h,spr[h].seq);
 
-	  dderror = k[seq[h].frame[1]].k->IsLost ();
-	  if (dderror == DDERR_SURFACELOST)
+	  if (k[seq[h].frame[1]].k == NULL)
+	    {
+	      figure_out (seq[h].data, 0);
+	    }
+	  else if (k[seq[h].frame[1]].k->IsLost () == DDERR_SURFACELOST)
 	    {
 	      get_word (seq[h].data, 2, word1);
 	      reload_sprites (word1, h, 0);
@@ -5040,7 +5642,7 @@
       {
 // Msg("Smartload: Loading seq %d..", spr[h].seq);
 
-	if (seq[h].frame[1] == 0)
+	if (seq[h].frame[1] == 0 || k[seq[h].frame[1]].k == NULL)
 	  {
 	    figure_out (seq[h].data, 0);
 	  }
@@ -6352,7 +7029,14 @@
   return (*change);
 }
 
-int
+//redink1 added for long values
+
+long
+change_sprite (int h, int val, long *change)
+{
+  return (long) change_sprite (h, val, (int *) change);
+} int
+
 change_edit (int h, int val, unsigned short *change)
 {
 //Msg("Searching sprite %s with val %d. Cur is %d", h, val, *change);
@@ -6446,6 +7138,7 @@
 	  }
       }
 }
+}
 
 void
 changedir (int dir1, int k, int base)
@@ -6683,6 +7376,9 @@
     }
   if (*pexper != fexp)
     {
+      if ((talk.active == false && item_screen == false && spr[1].freeze == 0)
+	  || fexp + 10 < fraise)
+	{
 //update screen experience
 
       fexp += 10;
@@ -6701,6 +7397,7 @@
 	    run_script (script);
 	}
     }
+    }
   if (drawexp)
     {
       draw_exp ();
@@ -6776,7 +7473,12 @@
   if (*pmagic_cost > 0)
     if (*pmagic_level > 0)
       {
-	int mnum = *pmagic_level / (*pmagic_cost / 100);
+	double mnumd = *pmagic_level;
+	mnumd *= 100;
+	mnumd /= *pmagic_cost;
+	int mnum = static_cast < int >(mnumd);
+//int mnum = *pmagic_level / (*pmagic_cost / 100);
+
 	if (mnum != last_magic_draw)
 	  {
 	    draw_mlevel (mnum);
@@ -8019,21 +8747,8 @@
 	strcpy (s, h);
 	return (1);
       }
-    if (compare (ev[1], "unfreeze"))
+    if (compare (ev[1], "show_console"))
       {
 	h = &h[strlen (ev[1])];
-	int p[20] = { 1, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
-	if (get_parms (ev[1], script, h, p))
-	  {
-//Msg("UnFreeze called for %d.", nlist[0]);
-
-	    if (spr[nlist[0]].active)
-	      spr[nlist[0]].freeze = 0;
-	    else
-	      Msg
-		("Couldn't unfreeze sprite %d in script %d, it doesn't exist.",
-		 nlist[0], script);
-	  }
-	strcpy (s, h);
-	return (0);
+	mConsoleActive = true;	/*int p[20] = {1,0,0,0,0,0,0,0,0,0}; if (get_parms(ev[1], script, h, p)) { if ( nlist[0] >= 1 ) { mConsoleActive = true; } else { mConsoleActive = false; } } returnint = 0; if ( mConsoleActive ) { returnint = 1; } */
       }
[...]
+//redink1
+
+    if (compare (ev[1], "sp_custom"))
+      {
+	h = &h[strlen (ev[1])];
+	int p[20] = { 2, 1, 1, 0, 0, 0, 0, 0, 0, 0 };
+	if (get_parms (ev[1], script, h, p) && spr[nlist[1]].active == TRUE)
+	  {
+	    if (nlist[1] < 1 || spr[nlist[1]].active == false)
+	      {
+		returnint = -1;
+	      }
+	    else
+	      {
+// If key doesn't exist, create it.
+
+		if (spr[nlist[1]].custom->find (slist[0]) ==
+		    spr[nlist[1]].custom->end ())
+		  {
+// spr[nlist[1]].custom->insert( std::make_pair( slist[0], 0 ) );
+
+		  }
+// Set the value
+
+		if (nlist[2] != -1)
+		  {
+		    spr[nlist[1]].custom->erase (slist[0]);
+// spr[nlist[1]].custom->insert( std::make_pair( slist[0], nlist[2] ) );
+
+		  }
+		returnint = spr[nlist[1]].custom->find (slist[0])->second;
+	      }
+	    return (0);
+	  }
+	returnint = -1;
+	return (0);
+      }
[...]
+    if (compare (ev[1], "set_callback_random"))
+      {
+	Msg ("setting callback random");
+	h = &h[strlen (ev[1])];
+	int p[20] = { 2, 1, 1, 0, 0, 0, 0, 0, 0, 0 };
+	if (get_parms (ev[1], script, h, p))
+	  {
+	    int cb = add_callback (slist[0], nlist[1], nlist[2], script);
+//got all parms, let do it
+
+	    returnint = cb;
+	  }
+	strcpy (s, h);
+	return (0);
+      }
+// redink1 added
+
+    if (compare (ev[1], "callback_kill"))
+      {
+	Msg ("setting callback random");
+	h = &h[strlen (ev[1])];
+	int p[20] = { 1, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
+	if (get_parms (ev[1], script, h, p))
+	  {
+	    if (nlist[0] >= 0 && nlist[0] <= 99)
+	      {
+		callback[nlist[0]].active = false;
+	      }
+	  }
+	strcpy (s, h);
+	return (0);
+      }
+    if (compare (ev[1], "set_dink_speed"))
+      {
+	Msg ("setting callback random");
+	h = &h[strlen (ev[1])];
+	int p[20] = { 1, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
+	if (get_parms (ev[1], script, h, p) && nlist[0] != 0)
+	  {
+	    dinkspeed = nlist[0];
+	  }
+	strcpy (s, h);
+	return (0);
+      }
+//redink1
+
+    if (compare (ev[1], "set_dink_base_push"))
+      {
+	Msg ("setting callback random");
+	h = &h[strlen (ev[1])];
+	int p[20] = { 1, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
+	if (get_parms (ev[1], script, h, p))
+	  {
+	    mDinkBasePush = nlist[0];
+	  }
+	strcpy (s, h);
+	return (0);
+      }
+    if (compare (ev[1], "reset_timer"))
+      {
+	h = &h[strlen (ev[1])];
+	time (&time_start);
+	play.minutes = 0;
+	strcpy (s, h);
+	return (0);
+      }
+    if (compare (ev[1], "set_keep_mouse"))
+      {
+	Msg ("setting callback random");
+	h = &h[strlen (ev[1])];
+	int p[20] = { 1, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
+	if (get_parms (ev[1], script, h, p))
+	  {
+	    keep_mouse = nlist[0];
+	  }
+	strcpy (s, h);
+	return (0);
+      }
+    if (compare (ev[1], "add_item"))
+      {
+	h = &h[strlen (ev[1])];
+	int p[20] = { 2, 1, 1, 0, 0, 0, 0, 0, 0, 0 };
+	if (get_parms (ev[1], script, h, p))
+	  {
+	    add_item (slist[0], nlist[1], nlist[2], false);
+	  }
+	strcpy (s, h);
+	return (0);
+      }
+    if (compare (ev[1], "add_exp"))
+      {
+	h = &h[strlen (ev[1])];
+	int p[20] = { 1, 1, 0, 0, 0, 0, 0, 0, 0, 0 };
+	if (get_parms (ev[1], script, h, p))
+	  {
+	    add_exp (nlist[0], nlist[1], true);
+	  }
+	strcpy (s, h);
+	return (0);
+      }
+    if (compare (ev[1], "add_magic"))
+      {
+	h = &h[strlen (ev[1])];
+	int p[20] = { 2, 1, 1, 0, 0, 0, 0, 0, 0, 0 };
+	if (get_parms (ev[1], script, h, p))
+	  {
+	    add_item (slist[0], nlist[1], nlist[2], true);
+	  }
+	strcpy (s, h);
+	return (0);
+      }
+    if (compare (ev[1], "kill_this_item"))
+      {
+	h = &h[strlen (ev[1])];
+	int p[20] = { 2, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
+	if (get_parms (ev[1], script, h, p))
+	  {
+	    kill_cur_item_script (slist[0]);
+	  }
+	strcpy (s, h);
+	return (0);
+      }
+    if (compare (ev[1], "kill_this_magic"))
+      {
+	h = &h[strlen (ev[1])];
+	int p[20] = { 2, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
+	if (get_parms (ev[1], script, h, p))
+	  {
+	    kill_cur_magic_script (slist[0]);
+	  }
+	strcpy (s, h);
+	return (0);
+      }
+    if (compare (ev[1], "show_bmp"))
+      {
+	Msg ("showing BMP");
+	h = &h[strlen (ev[1])];
+	int p[20] = { 2, 1, 1, 0, 0, 0, 0, 0, 0, 0 };
 	if (get_parms (ev[1], script, h, p))
 	  {
 	    wait.active = false;
@@ -9712,6 +11086,10 @@
 	int p[20] = { 1, 1, 0, 0, 0, 0, 0, 0, 0, 0 };
 	if (get_parms (ev[1], script, h, p))
 	  {
+//redink1 fix for freeze if hurt value is less than 0
+
+	    if (nlist[1] < 0)
+	      return (0);
 	    if (hurt_thing (nlist[0], nlist[1], 0) > 0)
 	      random_blood (spr[nlist[0]].x, spr[nlist[0]].y - 40, nlist[0]);
 	    if (spr[nlist[0]].nohit != 1)
@@ -9719,7 +11097,12 @@
 		if (locate (spr[nlist[0]].script, "HIT"))
 		  {
 		    if (rinfo[script]->sprite != 1000)
+		      {
 		      *penemy_sprite = rinfo[script]->sprite;
+//redink1 addition of missle_source stuff
+
+			*pmissle_source = rinfo[script]->sprite;
+		      }
 		    kill_returning_stuff (spr[nlist[0]].script);
 		    run_script (spr[nlist[0]].script);
 		  }
@@ -9802,10 +11185,14 @@
 	int p[20] = { 1, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
 	if (get_parms (ev[1], script, h, p))
 	  {
+	    if (nlist[0] == 0 || nlist[0] == 1)
+	      {
 	    screenlock = nlist[0];
-	    return (0);
 	  }
-	returnint = -1;
+	  }
+//redink1 - set screenlock() to return the screenlock value
+
+	returnint = screenlock;
 	return (0);
       }
     if (compare (ev[1], "stop_entire_game"))
@@ -9925,6 +11312,17 @@
 	returnint = -1;
 	return (0);
       }
+    if (compare (ev[1], "sp_move_x"))
+      {
+	h = &h[strlen (ev[1])];
+	int p[20] = { 1, 1, 0, 0, 0, 0, 0, 0, 0, 0 };
+	if (get_parms (ev[1], script, h, p))
+	  {
+	    change_sprite_noreturn (nlist[0], nlist[1], &spr[nlist[0]].mx);
+	    return (0);
+	  }
+	return (0);
+      }
     if (compare (ev[1], "sp_my"))
       {
 	h = &h[strlen (ev[1])];
@@ -9937,6 +11335,17 @@
 	returnint = -1;
 	return (0);
       }
+    if (compare (ev[1], "sp_move_y"))
+      {
+	h = &h[strlen (ev[1])];
+	int p[20] = { 1, 1, 0, 0, 0, 0, 0, 0, 0, 0 };
+	if (get_parms (ev[1], script, h, p))
+	  {
+	    change_sprite_noreturn (nlist[0], nlist[1], &spr[nlist[0]].my);
+	    return (0);
+	  }
+	return (0);
+      }
     if (compare (ev[1], "scripts_used"))
       {
 	h = &h[strlen (ev[1])];
@@ -10111,7 +11520,9 @@
 	      {
 		return (0);
 	      }
-	    if (compare (play.item[*pcur_magic].name, slist[0]))
+//redink1 fix so compare_magic works!
+
+	    if (compare (play.mitem[*pcur_magic].name, slist[0]))
 	      {
 		returnint = 1;
 	      }
