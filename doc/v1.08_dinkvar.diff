--- dv_canonical	2008-06-26 09:24:25.000000000 +0200
+++ dv2_canonical	2008-06-29 19:45:08.000000000 +0200
@@ -32,7 +32,11 @@
 //#include "midi.h"
 
 #include <fcntl.h>
 #include <malloc.h>
+
+//redink1 moves this here so could ignore keystrokes
+
+HWND hwnd;
 void check_midi (void);
 UINT midi_id;
 
@@ -49,11 +68,73 @@
 
 int dinkspeed = 3;
 int last_cd;
-char current_map[255] = "MAP.DAT";
+//redink1... uh... increased these to 255? I'm honestly not quite sure. It has been a while. They might have been hard-coded, and I created char strings for them?
+
+char current_map[50] = "MAP.DAT";
+char current_dat[50] = "DINK.DAT";
 int regcode, mycode;
 time_t time_start;
 bool item_screen = false;
 bool midi_active = true;
+//redink1 lets make a new save info thing
+
+char save_game_info[200] = "Level &level";
+//redink1 added this prototype to fix this save info declaration error thing
+
+void decipher_string (char line[200], int script);
+//redink1 and invertigo tags for windowed/high color mode
+
+bool truecolor = false;
+bool dinkpal = false;
+//redink1 int for truecolor transition
+
+int iTrueColorFadeTime = 0;
+bool bFadedDown = false;
+bool smooth_follow = false;
+unsigned short (*m16BitFadeValues)[30];
+unsigned char (*m8BitFadeValues)[30];
+enum ColorDepth
+{ ColorDepth16Bit_565, ColorDepth16Bit_555, ColorDepth24Bit, ColorDepth32Bit,
+    ColorDepthNotRecognized };
+ColorDepth mColorDepth = ColorDepthNotRecognized;
+bool mSwapped = false;
+//unsigned int mTotalTime = 0;
+
+//unsigned int mTotalCount = 0;
+
+ /*typedef std::vector<DWORD> FadeValues; 
+    //std::map<DWORD, FadeValues>* mPrecalculatedFadeValues; */
+
+//redink1 added for midi looping
+
+bool mLoopMidi = false;
+//redink1 added for base push
+
+unsigned int mDinkBasePush = 310;
+//redink1 added for true-color fade, amoung other things
+
+DWORD dwRMask;
+DWORD dwGMask;
+DWORD dwBMask;
+WORD wRBits;
+WORD wGBits;
+WORD wBBits;
+WORD wRPos;
+WORD wGPos;
+WORD wBPos;
+//redink1 added for recursive scope checking
+
+int get_var (int script, char *name);
+//redink1 added for console
+
+bool mConsoleActive = false;
+//std::string mConsoleLine;
+
+unsigned int mConsoleScript = 0;
+//std::vector<std::string> mConsoleLineHistory;
+
+unsigned short int mConsoleHistoryIndex = 0;
+unsigned int mConsoleReturnValue = 0;
 void init_scripts (void);
 int load_script (char filename[15], int sprite, bool set_sprite);
 void strchar (char *string, char ch);
@@ -64,7 +147,8 @@
 DWORD killcd (HWND hWndNotify, BYTE bTrack);
 void update_status_all (void);
 int add_sprite (int x1, int y, int brain, int pseq, int pframe);
-void add_exp (int num, int h);
+void load_info ();		//redink1
+void add_exp (int num, int h, bool addEvenIfNotLastSpriteHit = false);
 bool locate (int script, char proc[20]);
 bool exist (char name[255]);
 BOOL SoundStopEffect (int sound);
@@ -96,6 +180,15 @@
 const old_burn = 0;
 int burn_revision = 0;
 bool abort_this_flip = false;
+//redink1 added for font colors
+
+struct font_color
+{
+  int red;
+  int green;
+  int blue;
+};
+font_color font_colors[16];
 struct soundstruct
 {
   bool repeat;
@@ -153,7 +246,7 @@
   int timer;
 };
 talk_struct talk;
-char last_midi[15];
+char last_midi[15] = "";
 struct idata
 {
   int type;
@@ -172,7 +265,7 @@
 int flife, fexp, fstrength, fdefense, fgold, fmagic, fmagic_level, flifemax,
   fraise, last_magic_draw;
 int fcur_weapon, fcur_magic;
-const max_idata = 600;
+const max_idata = 1000;		//redink1
 int mbase_timing;
 idata id[max_idata];
 DWORD mold;
@@ -232,6 +325,19 @@
   int seq;
   int frame;
 };
+//redink1... for storing current tiles in save game
+
+struct player_info_tile
+{
+  char file[50];
+};
+//redink1 added for storing global functions
+
+struct global_function
+{
+  char file[10];
+  char func[20];
+};
 struct player_info
 {
   int version;
@@ -258,7 +364,14 @@
   int buff[95];
   DWORD dbuff[20];
   long lbuff[10];
-  char cbuff[6000];
+//redink1... use wasted space for storing file location of map.dat, dink.dat, palette, and tiles
+
+  char mapdat[50];
+  char dinkdat[50];
+  char palette[50];
+  player_info_tile tile[42];
+  global_function func[100];
+  char cbuff[750];
 };
 int push_active = 1;
 LOGFONT lf = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "" };
@@ -288,6 +401,15 @@
   bool skipnext;
   int onlevel;
   int proc_return;
+  int arg1;
+  int arg2;
+  int arg3;
+  int arg4;
+  int arg5;
+  int arg6;
+  int arg7;
+  int arg8;
+  int arg9;
 };
 bool first_frame = false;
 bool no_running_main = false;
@@ -314,6 +436,7 @@
 int in_x, in_y;
 int sp_brain = 0;
 int returnint = 0;
+bool bKeepReturnInt = false;
 char returnstring[200];
 int sp_speed = 0;
 char slist[10][200];
@@ -420,6 +543,12 @@
   int nodraw;
   int frame_delay;
   int picfreeze;
+//redink1
+
+  int bloodseq;
+  int bloodnum;
+// std::map<std::string, int>* custom;
+
 };
 struct seth_joy
 {
@@ -587,7 +716,7 @@
 HINSTANCE MyhInstance = NULL;
 bool mouse1 = false;
 int cur_sprite = 1;
-int playy = 399;
+int playy = 400;		//redink1's fix for the 'no sprites on pixel line above status bar' bug
 int cur_map, cur_tile;
 seth_joy sjoy;
 DWORD thisTickCount, lastTickCount;
@@ -607,6 +736,7 @@
 LPDIRECTDRAWSURFACE lpDDSTwo = NULL;	// Offscreen surface 2
 LPDIRECTDRAWSURFACE lpDDSTrick = NULL;	// Offscreen surface 2
 LPDIRECTDRAWSURFACE lpDDSTrick2 = NULL;	// Offscreen surface 2
+LPDIRECTDRAWSURFACE lpDDSFade = NULL;	//redink1 surface for true-color fade-downs
 bool trig_man = false;
 bool total_trigger = false;
 bool debug_mode = false;
@@ -635,7 +765,8 @@
 BYTE torusColors[256];		// Marks the colors used in the torus
 HWND hWndMain = NULL;
 JOYINFOEX jinfo;		//joystick info
-BOOL joystick = false;
+BOOL joystick = FALSE;
+BOOL disablejoystick = FALSE;
 hardness hmap;
 RECT tilerect[tile_screens];
 void
@@ -1940,10 +2089,15 @@
 	  hm.x[x1].y[y1] = get_hard_map (0, x1, y1);
 }}} void
 
-add_exp (int num, int h)
+add_exp (int num, int h, bool addEvenIfNotLastSpriteHit)
+{
+//redink1 fix - made work with all sprites when using add_exp DinkC command
+
+  if (addEvenIfNotLastSpriteHit == false)
 {
   if (spr[h].last_hit != 1)
     return;
+    }
   if (num > 0)
     {
 //add experience
@@ -2137,6 +2291,14 @@
       Msg ("Cannot find %s file!!!", current_map);
       return;
     }
+//redink1 set correctly so Dink appears on mini-map for warps and such
+
+//doesn't work, because 'num' is actually the offset in map.dat, not the map screen number
+
+//if (map.indoor[num] == 0)
+
+// play.last_map = num;
+
   lsize = sizeof (struct small_map);
   holdme = (lsize * (num - 1));
   fseek (fp, holdme, SEEK_SET);
@@ -2149,6 +2311,7 @@
     Msg ("ERROR: Couldn't read map %d?!?", num);
   fclose (fp);
   spr[1].move_active = false;
+  spr[1].move_nohard = false;
   spr[1].freeze = false;
   screenlock = 0;
   fill_whole_hard ();
@@ -2183,7 +2346,9 @@
 {
   FILE *fp;
   char crap[80];
-  sprintf (crap, "DINK.DAT");
+//redink1
+
+  sprintf (crap, current_dat);
   fp = fopen (crap, "wb");
   fwrite (&map, sizeof (struct map_info), 1, fp);
   fclose (fp);
@@ -2193,6 +2358,9 @@
 {
   FILE *fp;
   char crap[80];
+//redink1 created this
+
+  char info_temp[200];
 //lets set some vars first
 
   play.x = spr[1].x;
@@ -2216,7 +2384,17 @@
   play.base_idle = spr[1].base_idle;
   play.base_walk = spr[1].base_walk;
   play.base_hit = spr[1].base_hit;
-  sprintf (play.gameinfo, "Level %d", *plevel);
+//redink1 - save game things for storing new map, palette, and tile information
+
+  strncpy (play.mapdat, current_map, 50);
+  strncpy (play.dinkdat, current_dat, 50);
+//redink1 code for custom save game names
+
+  strcpy (info_temp, save_game_info);
+  decipher_string (info_temp, 0);
+  strncpy (play.gameinfo, info_temp, 77);
+//sprintf(play.gameinfo, "Level %d",*plevel);
+
   last_saved_game = num;
   sprintf (crap, "SAVE%d.DAT", num);
   fp = fopen (crap, "wb");
@@ -2370,6 +2548,59 @@
     {
       fread (&play, sizeof (play), 1, fp);
       fclose (fp);
+//redink1 - new map, if exist
+
+      if (strlen (play.mapdat) > 0 && strlen (play.dinkdat) > 0)
+	{
+	  strcpy (current_map, play.mapdat);
+	  strcpy (current_dat, play.dinkdat);
+	  load_info ();
+	}
+//redink1 - load palette
+
+      if (strlen (play.palette) > 0)
+	{
+	  LPDIRECTDRAWSURFACE oldTrick =
+	    DDLoadBitmap (lpDD, play.palette, 0, 0);
+	  lpDDPal = DDLoadPalette (lpDD, play.palette);
+	  if (lpDDPal)
+	    {
+	      lpDDSPrimary->SetPalette (lpDDPal);
+	      lpDDPal->GetEntries (0, 0, 256, pe);
+	      lpDDPal->GetEntries (0, 0, 256, real_pal);
+	    }
+	  oldTrick->Release ();
+	}
+//redink1 - reload tiles
+
+      char tile[50];
+      for (int i = 1; i <= 41; i++)
+	{
+//Need to unload old tiles...
+
+	  tiles[i]->Release ();
+//Which tiles are we loading, new or default?
+
+	  if (strlen (play.tile[i].file) > 0)
+	    {
+//Check the original directory
+
+	      if (!exist (play.tile[i].file))
+		sprintf (tile, "..\\DINK\\%s", play.tile[i].file);
+	      else
+		strcpy (tile, play.tile[i].file);
+	    }
+	  else
+	    {
+	      sprintf (tile, "tiles\\TS%02d.bmp", i);
+	      if (!exist (tile))
+		sprintf (tile, "..\\dink\\tiles\\TS%02d.BMP", i);
+	    }
+//Load in the tiles...
+
+	  tiles[i] = DDTileLoad (lpDD, tile, 0, 0, i);
+	  DDSetColorKey (tiles[i], RGB (0, 0, 0));
+	}
       spr[1].damage = 0;
       spr[1].x = play.x;
       spr[1].y = play.y;
@@ -2443,6 +2677,11 @@
       Msg ("Loaded map.");
       draw_map_game ();
       Msg ("Map drawn.");
+//redink1 fixes
+
+      fexp = *pexper;
+      draw_status_all ();
+      Msg ("Status drawn.");
       last_saved_game = num;
       return (true);
     }
@@ -2606,14 +2845,14 @@
 load_info (void)
 {
   FILE *fp;
-  char crap[80];
-  sprintf (crap, "DINK.DAT");
-  fp = fopen (crap, "rb");
+//redink1 changed 'crap' to 'current_dat'
+
+  fp = fopen (current_dat, "rb");
   if (!fp)
     {
 //fclose(fp);
 
-      fp = fopen (crap, "wb");
+      fp = fopen (current_dat, "wb");
 //make new data file
 
       strcpy (map.name, "Smallwood");
@@ -2723,6 +2962,8 @@
   return psurf;
 }				/* DDCreateSurface */
 
+//redink1 and Invertigo fix for windowed/true color mode
+
 void
 load_sprite_pak (char org[100], int nummy, int speed, int xoffset,
 		 int yoffset, RECT hardbox, bool notanim, bool black,
@@ -2738,6 +2979,7 @@
   DDCOLORKEY ddck;
   int x, y, dib_pitch;
   BYTE *src, *dst;
+  DWORD ddst;
   char fname[20];
   LPTSTR dump;
 //IDirectDrawSurface *pdds;
@@ -2829,16 +3071,50 @@
 
 	      return;
 	    }
+//redink1 modified this to work with every color depth
+
+//Ok, what we do here is take each color, shift it right to get rid of any
+
+//lower-order bits that we don't use, then shift it left to go to the correct
+
+//position. Should work fine with 16-24-32 bit color depth.
+
+#define _RGBXBIT(r, g, b) ( (r >> (8 - wRBits) << wRPos) | (g >> (8 - wGBits) << wGPos) | (b >> (8 - wBBits) << wBPos) )
+	  PALETTEENTRY ape[256];
+	  DWORD dwBlack;
+	  DWORD dwNearBlack;
+	  DWORD dwWhite;
+	  DWORD dwNearWhite;
+	  if (truecolor)
+	    {
+	      if (dinkpal)
+		{
+		  memcpy (ape, real_pal, sizeof (PALETTEENTRY) * 256);
+		}
+	      else
+		{
+		  byte *palzor = (byte *) pbf + 54;
+		  for (int pcount = 0; pcount < 256; pcount++)
+		    {
+		      ape[pcount].peRed = palzor[pcount * 4 + 2];
+		      ape[pcount].peGreen = palzor[pcount * 4 + 1];
+		      ape[pcount].peBlue = palzor[pcount * 4];
+		}} dwBlack =
+		_RGBXBIT (ape[255].peRed, ape[255].peGreen, ape[255].peBlue);
+	      dwNearBlack =
+		_RGBXBIT (ape[249].peRed, ape[255].peGreen, ape[255].peBlue);
+	      dwWhite =
+		_RGBXBIT (ape[0].peRed, ape[0].peGreen, ape[0].peBlue);
+	      dwNearWhite =
+		_RGBXBIT (ape[30].peRed, ape[30].peGreen, ape[30].peBlue);
+	    }
 	  byte *pic;
 	  pic = (byte *) pbf + 1078;
 //Msg("Pic's size is now %d.",sizeof(pic));
 
-	  bm.bmWidth = pbi->biWidth;
-	  bm.bmHeight = pbi->biHeight;
-	  bm.bmWidthBytes = 32;
-	  bm.bmPlanes = pbi->biPlanes;
-	  bm.bmBitsPixel = pbi->biBitCount;
-	  bm.bmBits = pic;
+//redink1 THIS DOESN'T DO ANYTHING!!!! ARGHAGHARHA!
+
+	  /*bm.bmWidth = pbi->biWidth; bm.bmHeight = pbi->biHeight; bm.bmWidthBytes = 32; bm.bmPlanes = pbi->biPlanes; bm.bmBitsPixel = pbi->biBitCount; bm.bmBits = pic; */
 //
 
 // create a DirectDrawSurface for this bitmap
@@ -2850,7 +3126,7 @@
 	  ddsd.dwFlags = DDSD_CAPS | DDSD_HEIGHT | DDSD_WIDTH;
 	  ddsd.ddsCaps.dwCaps = DDSCAPS_OFFSCREENPLAIN | DDSCAPS_SYSTEMMEMORY;
 	  ddsd.dwWidth = pbi->biWidth;
-	  ddsd.dwHeight = pbi->biHeight;
+	  ddsd.dwHeight = pbi->biHeight;	// + 1; //redink1 fixed crashing in 16-bit mode... would overflow by a byte or two by writing dwords, really weird bug. Eh, actually moved solution to everywhere we update a DWORD, include any trailing bits that were there before. Saves memory.
 	  if (k[sprite].k != NULL)
 	    k[sprite].k->Release ();
 	  if (lpDD->CreateSurface (&ddsd, &k[sprite].k, NULL) != DD_OK)
@@ -2868,6 +3144,9 @@
 		  dib_pitch = (pbi->biWidth + 3) & ~3;
 		  src = (BYTE *) pic + dib_pitch * (pbi->biHeight - 1);
 		  dst = (BYTE *) ddsd.lpSurface;
+		  ddst = (DWORD) ddsd.lpSurface;
+		  int bytesPerPixel = ddsd.ddpfPixelFormat.dwRGBBitCount >> 3;	//Divide by 8, basically
+		  DWORD dwPixel;
 		  if (leftalign)
 		    {
 //Msg("left aligning..");
@@ -2876,6 +3155,30 @@
 			{
 			  for (x = 0; x < (int) pbi->biWidth; x++)
 			    {
+			      if (truecolor)
+				{
+				  dwPixel =
+				    _RGBXBIT (ape[src[x]].peRed,
+					      ape[src[x]].peGreen,
+					      ape[src[x]].peBlue);
+				  if (dwPixel == dwBlack)
+				    {
+// Msg("Found a 255...");
+
+				      dwPixel = dwNearBlack;
+				    }
+				  else if (dwPixel == dwWhite)
+				    {
+				      dwPixel = dwNearWhite;
+				    }
+//Make sure to or it with the rest of the DWORD present, just in case it overflows the buffer
+
+				  *((DWORD *) ddst) =
+				    dwPixel | *((DWORD *) ddst) & ~dwWhite;
+				  ddst += bytesPerPixel;
+				}
+			      else
+				{
 			      dst[x] = src[x];
 			      if (dst[x] == 0)
 				{
@@ -2888,26 +3191,57 @@
 				  dst[x] = 249;
 				}
 			    }
+			    }
+//redink1 switched to 'better' version
+
+			  ((DWORD) ddst) += ddsd.lPitch - ((int) pbi->biWidth) * bytesPerPixel;	//ddst += ddsd.lPitch / 4;
 			  dst += ddsd.lPitch;
 			  src -= dib_pitch;
-			}
-		    }
+		    }}
 		  else if (black)
 		    {
 		      for (y = 0; y < (int) pbi->biHeight; y++)
 			{
 			  for (x = 0; x < (int) pbi->biWidth; x++)
 			    {
+			      if (truecolor)
+				{
+				  dwPixel =
+				    _RGBXBIT (ape[src[x]].peRed,
+					      ape[src[x]].peGreen,
+					      ape[src[x]].peBlue);
+				  if (dwPixel == dwWhite)
+				    {
+// Msg("Found a 255...");
+
+				      dwPixel = dwNearWhite;
+				    }
+				  else if (dwPixel == dwBlack)
+				    {
+				      dwPixel = dwWhite;
+				    }
+				  *((DWORD *) ddst) =
+				    dwPixel | *((DWORD *) ddst) & ~dwWhite;;
+				  ddst += bytesPerPixel;	/*ddst[x] = _RGB24BIT(ape[src[x]].peRed, ape[src[x]].peGreen, ape[src[x]].peBlue); if (ddst[x] == _RGB24BIT(ape[0].peRed, ape[0].peGreen, ape[0].peBlue)) { 
+								   // Msg("Found a 255...");
+
+								   ddst[x] = _RGB24BIT(ape[30].peRed, ape[30].peGreen, ape[30].peBlue); } if (!dinkpal) { if (ddst[x] == _RGB24BIT(ape[255].peRed, ape[255].peGreen, ape[255].peBlue)) { ddst[x] = _RGB24BIT(ape[0].peRed, ape[0].peGreen, ape[0].peBlue); } } */
+				}
+			      else
+				{
 			      dst[x] = src[x];
 			      if (dst[x] == 0)
 				{
 				  dst[x] = 30;
 				}
 			    }
+			    }
+//redink1 switched to 'better' version
+
+			  ((DWORD) ddst) += ddsd.lPitch - ((int) pbi->biWidth) * bytesPerPixel;	//
 			  dst += ddsd.lPitch;
 			  src -= dib_pitch;
-			}
-		    }
+		    }}
 		  else
 		    {
 //doing white
@@ -2916,6 +3250,28 @@
 			{
 			  for (x = 0; x < (int) pbi->biWidth; x++)
 			    {
+			      if (truecolor)
+				{
+				  dwPixel =
+				    _RGBXBIT (ape[src[x]].peRed,
+					      ape[src[x]].peGreen,
+					      ape[src[x]].peBlue);
+				  if (dwPixel == dwBlack)
+				    {
+// Msg("Found a 255...");
+
+				      dwPixel = dwNearBlack;
+				    }
+				  else if (dwPixel == dwWhite)
+				    {
+				      dwPixel = dwBlack;
+				    }
+				  *((DWORD *) ddst) =
+				    dwPixel | *((DWORD *) ddst) & ~dwWhite;;
+				  ddst += bytesPerPixel;	/*ddst[x] = _RGB24BIT(ape[src[x]].peRed, ape[src[x]].peGreen, ape[src[x]].peBlue); if (ddst[x] == _RGB24BIT(ape[255].peRed, ape[255].peGreen, ape[255].peBlue)) { ddst[x] = _RGB24BIT(ape[249].peRed, ape[249].peGreen, ape[249].peBlue); } if (!dinkpal) { if (ddst[x] == _RGB24BIT(ape[0].peRed, ape[0].peGreen, ape[0].peBlue)) { ddst[x] = _RGB24BIT(ape[255].peRed, ape[255].peGreen, ape[255].peBlue); } } */
+				}
+			      else
+				{
 			      dst[x] = src[x];
 			      if (dst[x] == 255)
 				{
@@ -2924,11 +3280,13 @@
 				  dst[x] = 249;
 				}
 			    }
+			    }
+//redink1 switched to 'better' version
+
+			  ((DWORD) ddst) += ddsd.lPitch - ((int) pbi->biWidth) * bytesPerPixel;	//ddst += ddsd.lPitch / 4;
 			  dst += ddsd.lPitch;
 			  src -= dib_pitch;
-			}
-		    }
-		  IDirectDrawSurface_Unlock (k[sprite].k, NULL);
+		    }} IDirectDrawSurface_Unlock (k[sprite].k, NULL);
 		}
 	      else
 		{
@@ -3976,7 +4359,14 @@
   if (ddrval == DDERR_WASSTILLDRAWING)
     goto again3;
   fraise = next_raise ();
+  if (*pexper < fraise)
+    {
   fexp = *pexper;
+    }
+  else
+    {
+      fexp = fraise - 1;
+    }
   fstrength = *pstrength;
   fmagic = *pmagic;
   fgold = *pgold;
@@ -3992,10 +4382,10 @@
   draw_icons ();
   if (*pmagic_cost > 0)
     if (*pmagic_level > 0)
-      draw_mlevel (*pmagic_level / (*pmagic_cost / 100));
-}
+      draw_mlevel (*pmagic_level / static_cast <
+		   double >(*pmagic_cost) / 100.0);
+} bool
 
-bool
 inside_box (int x1, int y1, RECT box)
 {
   if (x1 > box.right)
@@ -4054,6 +4444,15 @@
 	  spr[x].strength = 0;
 	  spr[x].damage = 0;
 	  spr[x].defense = 0;
+	  if (spr[x].custom == NULL)
+	    {
+// spr[x].custom = new std::map<std::string, int>;
+
+	    }
+	  else
+	    {
+	      spr[x].custom->clear ();
+	    }
 	  return (x);
 	}
     }
@@ -4065,8 +4464,6 @@
 {
   RECT math;
   int sz, sy, x_offset, y_offset;
-  int txoffset = k[getpic (h)].xoffset;
-  int tyoffset = k[getpic (h)].yoffset;
   int mplayx = playx;
   int mplayl = playl;
   int mplayy = playy;
@@ -4085,9 +4482,15 @@
       else
 	Msg ("Yo, sprite %d has a bad pic. (Map %d) Seq %d, Frame %d", h,
 	     *pmap, spr[h].pseq, spr[h].pframe);
+//redink1 added to fix frame-not-in-memory immediately
+
+      if (spr[h].pseq != 0)
+	check_seq_status (spr[h].pseq);
 //spr[h].pic = 44;
 
     }
+  int txoffset = k[getpic (h)].xoffset;
+  int tyoffset = k[getpic (h)].yoffset;
   *box_real = k[getpic (h)].box;
   CopyRect (&krect, &k[getpic (h)].box);
   if (spr[h].size != 100)
@@ -4117,6 +4520,24 @@
 							  0) | (spr[h].alt.
 								right != 0))
     {
+//redink1 checks for correct box stuff
+
+      if (spr[h].alt.left < 0)
+	spr[h].alt.left = 0;
+      if (spr[h].alt.left > k[getpic (h)].box.right)
+	spr[h].alt.left = k[getpic (h)].box.right;
+      if (spr[h].alt.top < 0)
+	spr[h].alt.top = 0;
+      if (spr[h].alt.top > k[getpic (h)].box.bottom)
+	spr[h].alt.top = k[getpic (h)].box.bottom;
+      if (spr[h].alt.right < 0)
+	spr[h].alt.right = 0;
+      if (spr[h].alt.right > k[getpic (h)].box.right)
+	spr[h].alt.right = k[getpic (h)].box.right;
+      if (spr[h].alt.bottom < 0)
+	spr[h].alt.bottom = 0;
+      if (spr[h].alt.bottom > k[getpic (h)].box.bottom)
+	spr[h].alt.bottom = k[getpic (h)].box.bottom;
 //spr[h].alt.bottom = 10; 
 
       box_crap->left = box_crap->left + spr[h].alt.left;
@@ -4651,6 +5072,7 @@
 	      if (rinfo[script]->sprite != 1000)
 		{
 		  spr[rinfo[script]->sprite].move_active = false;
+		  spr[rinfo[script]->sprite].move_nohard = false;
 		}
 	      rinfo[script]->skipnext = false;
 	      rinfo[script]->onlevel = 0;
@@ -4714,10 +5136,62 @@
       sprintf (crap, "%d", script);
       return;
     }
+//v1.08 special variables.
+
+  if (compare (crap, "&return"))
+    {
+      sprintf (crap, "%d", returnint);
+      return;
+    }
+  if (compare (crap, "&arg1"))
+    {
+      sprintf (crap, "%d", rinfo[script]->arg1);
+      return;
+    }
+  if (compare (crap, "&arg2"))
+    {
+      sprintf (crap, "%d", rinfo[script]->arg2);
+      return;
+    }
+  if (compare (crap, "&arg3"))
+    {
+      sprintf (crap, "%d", rinfo[script]->arg3);
+      return;
+    }
+  if (compare (crap, "&arg4"))
+    {
+      sprintf (crap, "%d", rinfo[script]->arg4);
+      return;
+    }
+  if (compare (crap, "&arg5"))
+    {
+      sprintf (crap, "%d", rinfo[script]->arg5);
+      return;
+    }
+  if (compare (crap, "&arg6"))
+    {
+      sprintf (crap, "%d", rinfo[script]->arg6);
+      return;
+    }
+  if (compare (crap, "&arg7"))
+    {
+      sprintf (crap, "%d", rinfo[script]->arg7);
+      return;
+    }
+  if (compare (crap, "&arg8"))
+    {
+      sprintf (crap, "%d", rinfo[script]->arg8);
+      return;
+    }
+  if (compare (crap, "&arg9"))
+    {
+      sprintf (crap, "%d", rinfo[script]->arg9);
+      return;
+    }
   for (int i = 1; i < max_vars; i++)
     {
       if (play.var[i].active == true)
-	if ((play.var[i].scope == 0) | (play.var[i].scope == script))
+	if (i == get_var (script, play.var[i].name))	//redink1 changed for recursive scoping
 	  if (compare (play.var[i].name, crap))
 	    {
 	      sprintf (crap, "%d", play.var[i].var);
@@ -4728,29 +5202,142 @@
     }
 }
 
-void
-decipher_string (char line[200], int script)
+//redink1 added to recursively check scope
+
+ /*bool recurse_scope(int var, int script) { 
+    //if the script matches, return true!
+
+    if (play.var[var].scope == script) return true; 
+    //If it doesn't match, and we have a proc return, go down the rabbit hole
+
+    if (rinfo[script] && rinfo[script]->proc_return != 0) return recurse_scope(var, rinfo[script]->proc_return); 
+    //Otherwise, return false
+
+    return false; } */
+//redink1 added, grabs the var index matching 'name' with the shortest scope. Basically iterates for each scope seperate until it finds a match.
+
+int
+get_var (int script, char *name)
 {
-  char crap[20];
-  char buffer[20];
-  char crab[100];
-  int mytime;
-  for (int i = 1; i < max_vars; i++)
+//Can optimize here, by searching through variable array for start and end limits
+
+//Loop forever...
+
+  while (1)
     {
-      if (play.var[i].active == true)
-	if ((play.var[i].scope == 0) | (play.var[i].scope == script))
+//We'll start going through every var, starting at one
+
+      int var = 1;
+      while (var < max_vars)
 	  {
-	    sprintf (crap, "%d", play.var[i].var);
-	    replace (play.var[i].name, crap, line);
-// check_for_real_vars(crap, i);
+//Okay... make sure the var is active,
 
+//The scope should match the script,
+
+//Then make sure the name is the same.
+
+	  if (play.var[var].active && play.var[var].scope == script
+	      && compare (play.var[var].name, name))
+	    return var;
+//Otherwise, go to the next var.
+
+	  var++;
 	  }
+//If we just went through the global list, let's return
+
+      if (script <= 0)
+	break;
+//Bugfix... if there is no rinfo[script] entry (like if kill this task was used), we go directly to the globals.
+
+//Thanks Tal!
+
+//if (!rinfo[script])
+
+// script = 0;
+
+//Go into the next proc from the script. If there are no parent procs, it should be 0, which is global.
+
+//else
+
+// script = rinfo[script]->proc_return;
+
+//Changed to not reference the parent procedure's variable list at all... just go on to globals.
+
+      script = 0;
     }
-  if ((strchr (line, '&') != NULL) && (script != 0))
-    {
-      replace ("&current_sprite", ltoa (rinfo[script]->sprite, buffer, 10),
+  return 0;
+}
+
+//redink1 changes for replacing var in string
+
+bool
+recurse_var_replace (int i, int script, char *line, char *prevar)
+{
+  while (i < max_vars)
+    {
+//First, make sure the variable is active.
+
+//Then, make sure it is in scope,
+
+//Then, see if the variable name is in the line
+
+//Then, prevar is null, or if prevar isn't null, see if current variable starts with prevar
+
+      if (play.var[i].active && i == get_var (script, play.var[i].name)
+	  && strstr (line, play.var[i].name) && (prevar == NULL
+						 || prevar != NULL
+						 && strstr (play.var[i].name,
+							    prevar)))
+	{
+//Look for shorter variables
+
+	  if (!recurse_var_replace (i + 1, script, line, play.var[i].name))
+	    {
+//we didn't find any, so we replace!
+
+	      char crap[20];
+	      sprintf (crap, "%d", play.var[i].var);
+	      replace (play.var[i].name, crap, line);
+//return true;
+
+	    }
+	}
+      i++;
+    } return false;
+}
+
+void
+decipher_string (char line[200], int script)
+{
+  char crap[20];
+  char buffer[20];
+  char crab[100];
+  int mytime;
+//redink1 replaced with recursive function for finding longest variable
+
+  recurse_var_replace (1, script, line, NULL);	/*for (int i = 1; i < max_vars; i ++) { if (play.var[i].active == true) if ( (play.var[i].scope == 0) || recurse_scope(play.var[i].scope, script) ) { sprintf(crap, "%d", play.var[i].var); replace(play.var[i].name, crap, line); 
+						   // check_for_real_vars(crap, i);
+
+						   //break;
+
+						   } } */
+  if ((strchr (line, '&') != NULL) && (script != 0))
+    {
+      replace ("&current_sprite", ltoa (rinfo[script]->sprite, buffer, 10),
 	       line);
       replace ("&current_script", ltoa (script, buffer, 10), line);
+//v1.08 special variables.
+
+      replace ("&return", ltoa (returnint, buffer, 10), line);
+      replace ("&arg1", ltoa (rinfo[script]->arg1, buffer, 10), line);
+      replace ("&arg2", ltoa (rinfo[script]->arg2, buffer, 10), line);
+      replace ("&arg3", ltoa (rinfo[script]->arg3, buffer, 10), line);
+      replace ("&arg4", ltoa (rinfo[script]->arg4, buffer, 10), line);
+      replace ("&arg5", ltoa (rinfo[script]->arg5, buffer, 10), line);
+      replace ("&arg6", ltoa (rinfo[script]->arg6, buffer, 10), line);
+      replace ("&arg7", ltoa (rinfo[script]->arg7, buffer, 10), line);
+      replace ("&arg8", ltoa (rinfo[script]->arg8, buffer, 10), line);
+      replace ("&arg9", ltoa (rinfo[script]->arg9, buffer, 10), line);
       if (decipher_savegame != 0)
 	{
 	  if (play.button[decipher_savegame] == 1)
@@ -4782,7 +5369,9 @@
 	if (exist (crap))
 	  {
 	    load_game_small (decipher_savegame, crab, &mytime);
-	    sprintf (line, "Slot %d - %d:%d - %s", decipher_savegame,
+//redink1 fix for savegame time bug
+
+	    sprintf (line, "Slot %d - %d:%02d - %s", decipher_savegame,
 		     (mytime / 60), mytime - ((mytime / 60) * 60), crab);
 //sprintf(line, "In Use"); 
 
@@ -4802,6 +5391,7 @@
 bool
 get_parms (char proc_name[20], int script, char *h, int p[10])
 {
+  memset (nlist, 0, 10 * sizeof (int));
   char crap[100];
   strip_beginning_spaces (h);
   if (h[0] == '(')
@@ -4812,7 +5402,7 @@
     }
   else
     {
-      Msg ("Missing ( in %s, offset %s.", rinfo[script]->name,
+      Msg ("Missing ( in %s, offset %d.", rinfo[script]->name,
 	   rinfo[script]->current);
       return (false);
     }
@@ -4954,6 +5544,15 @@
 	  spr[x].damage = 0;
 	  spr[x].defense = 0;
 	  spr[x].hard = 1;
+	  if (spr[x].custom == NULL)
+	    {
+// spr[x].custom = new std::map<std::string, int>;
+
+	    }
+	  else
+	    {
+	      spr[x].custom->clear ();
+	    }
 	  return (x);
 	}
     }
@@ -5016,8 +5615,11 @@
 
 //Msg("Sprite %d's seq is %d",h,spr[h].seq);
 
-	  dderror = k[seq[h].frame[1]].k->IsLost ();
-	  if (dderror == DDERR_SURFACELOST)
+	  if (k[seq[h].frame[1]].k == NULL)
+	    {
+	      figure_out (seq[h].data, 0);
+	    }
+	  else if (k[seq[h].frame[1]].k->IsLost () == DDERR_SURFACELOST)
 	    {
 	      get_word (seq[h].data, 2, word1);
 	      reload_sprites (word1, h, 0);
@@ -5040,7 +5642,7 @@
       {
 // Msg("Smartload: Loading seq %d..", spr[h].seq);
 
-	if (seq[h].frame[1] == 0)
+	if (seq[h].frame[1] == 0 || k[seq[h].frame[1]].k == NULL)
 	  {
 	    figure_out (seq[h].data, 0);
 	  }
@@ -5050,8 +5652,7 @@
 
 //Msg("Sprite %d's seq is %d",h,spr[h].seq);
 
-	    dderror = k[seq[h].frame[1]].k->IsLost ();
-	    if (dderror == DDERR_SURFACELOST)
+	    if (k[seq[h].frame[1]].k->IsLost () == DDERR_SURFACELOST)
 	      {
 		get_word (seq[h].data, 2, word1);
 		reload_sprites (word1, h, 0);
@@ -5178,7 +5779,7 @@
 	{
 	  if (compare (play.var[i].name, name))
 	    {
-	      if (scope == play.var[i].scope)
+	      if (play.var[i].scope == scope)	//redink1 changed to check recursively... then changed back. Hrm.
 		{
 //Msg("Found match for %s.", name);
 
@@ -5190,6 +5791,34 @@
   return (0);
 }
 
+//redink1 added this to make new global functions
+
+void
+make_function (char file[10], char func[20])
+{
+//See if it already exists
+
+  bool exists = false;
+  int i;
+  for (i = 0; strlen (play.func[i].func) > 0 && i < 100; i++)
+    {
+      if (compare (func, play.func[i].func))
+	{
+	  exists = true;
+	  break;
+	}
+    }
+  if (exists)
+    {
+      strncpy (play.func[i].file, file, 10);
+    }
+  else
+    {
+      strncpy (play.func[0].file, file, 10);
+      strncpy (play.func[0].func, func, 20);
+    }
+}
+
 void
 make_int (char name[80], int value, int scope, int script)
 {
@@ -5236,26 +5865,24 @@
 	    char rest[200])
 {
   int k;
-  int newret;
+//redink1 set newret to NULL so debug errors did not appear.
+
+  int newret = NULL;		// = NULL;
   if (name[0] != '&')
     {
       Msg ("ERROR (var equals): Unknown var %s in %s offset %d.", name,
 	   rinfo[script]->name, rinfo[script]->current);
       return (0);
     }
-  for (int i = 1; i < max_vars; i++)
-    {
-      if (play.var[i].active == true)
-	{
-	  if ((play.var[i].scope == 0) | (play.var[i].scope == script))
-	    if (compare (name, play.var[i].name))
+  int i = get_var (script, name);
+  if (i > 0)
 	      {
+      goto next;
+    }				/*for (int i = 1; i < max_vars; i++) { if (play.var[i].active == true) { if (i == 71) { i = 71; } if ( (play.var[i].scope == 0 || recurse_scope(i, script)) && compare(name, play.var[i].name) ) //redink1 changed to check recursive scope
+
 //found var
 
-		goto next;
-	      }
-	}
-    }
+				   goto next; } } */
   Msg ("ERROR: (var equals2) Unknown var %s in %s offset %d.", name,
        rinfo[script]->name, rinfo[script]->current);
   return (0);
@@ -5268,20 +5895,18 @@
     }
   if (strchr (newname, ';') != NULL)
     replace (";", "", newname);
-  for (k = 1; k < max_vars; k++)
-    {
-      if (play.var[k].active == true)
-	{
-	  if ((play.var[i].scope == 0) | (play.var[i].scope == script))
-	    if (compare (newname, play.var[k].name))
+//redink1 fixed for scope and such
+
+  k = get_var (script, newname);
+  if (k > 0)
 	      {
 		newval = play.var[k].var;
+      goto next2;
+    }				/*for (k = 1; k < max_vars; k++) { if (play.var[k].active == true) { if ( (play.var[k].scope == 0) || recurse_scope(k, script) ) //redink1 changed i to k, made it so can set the parent proc's local variables.
+				   if (compare(newname, play.var[k].name)) { newval = play.var[k].var; 
 //found var
 
-		goto next2;
-	      }
-	}
-    }
+				   goto next2; } } } */
   if (compare (newname, "&current_sprite"))
     {
       newval = rinfo[script]->sprite;
@@ -5292,6 +5917,58 @@
       newval = script;
       goto next2;
     }
+//v1.08 special variables.
+
+  if (compare (newname, "&return"))
+    {
+      newval = returnint;
+      goto next2;
+    }
+  if (compare (newname, "&arg1"))
+    {
+      newval = rinfo[script]->arg1;
+      goto next2;
+    }
+  if (compare (newname, "&arg2"))
+    {
+      newval = rinfo[script]->arg2;
+      goto next2;
+    }
+  if (compare (newname, "&arg3"))
+    {
+      newval = rinfo[script]->arg3;
+      goto next2;
+    }
+  if (compare (newname, "&arg4"))
+    {
+      newval = rinfo[script]->arg4;
+      goto next2;
+    }
+  if (compare (newname, "&arg5"))
+    {
+      newval = rinfo[script]->arg5;
+      goto next2;
+    }
+  if (compare (newname, "&arg6"))
+    {
+      newval = rinfo[script]->arg6;
+      goto next2;
+    }
+  if (compare (newname, "&arg7"))
+    {
+      newval = rinfo[script]->arg7;
+      goto next2;
+    }
+  if (compare (newname, "&arg8"))
+    {
+      newval = rinfo[script]->arg8;
+      goto next2;
+    }
+  if (compare (newname, "&arg9"))
+    {
+      newval = rinfo[script]->arg9;
+      goto next2;
+    }
   newval = atol (newname);
 next2:if (math == '=')
     play.var[i].var = newval;
@@ -5781,7 +6458,7 @@
   mciOpenParms.lpstrDeviceType = "sequencer";
   mciOpenParms.lpstrElementName = lpszMIDIFileName;
   if (dwReturn =
-      mciSendCommand (NULL, MCI_OPEN, MCI_OPEN_TYPE | MCI_OPEN_ELEMENT,
+      mciSendCommand (0, MCI_OPEN, MCI_OPEN_TYPE | MCI_OPEN_ELEMENT,
 		      (DWORD) (LPVOID) & mciOpenParms))
     {
 // Failed to open device. Don't close it; just return error.
@@ -5840,7 +6517,7 @@
 {
 //no midi stuff right now
 
-  if (::sound_on == false)
+  if (sound_on == false)
     return true;
   char buf[256];
   char crap[256];
@@ -5848,7 +6525,7 @@
     {
       if (nothing_playing ())
 	{
-	  Msg ("I think %s is already playing, I should skip it it...",
+	  Msg ("I think %s is already playing, I should skip it...",
 	       sFileName);
 	  return (false);
 	}
@@ -6352,7 +7029,14 @@
   return (*change);
 }
 
-int
+//redink1 added for long values
+
+long
+change_sprite (int h, int val, long *change)
+{
+  return (long) change_sprite (h, val, (int *) change);
+} int
+
 change_edit (int h, int val, unsigned short *change)
 {
 //Msg("Searching sprite %s with val %d. Cur is %d", h, val, *change);
@@ -6402,7 +7086,7 @@
 void
 draw_sprite_game (LPDIRECTDRAWSURFACE lpdest, int h)
 {
-  if (::g_b_kill_app)
+  if (g_b_kill_app)
     return;			//don't try, we're quitting
   if (spr[h].brain == 8)
     return;
@@ -6414,6 +7098,14 @@
   ddbltfx.dwSize = sizeof (ddbltfx);
   ddbltfx.dwFillColor = 0;
   if (get_box (h, &box_crap, &box_real))
+    {
+//redink1 error checking for invalid rectangle
+
+      if (box_crap.left >= box_crap.right || box_crap.top >= box_crap.bottom)
+	return;
+//redink1 error checking for out-of-bounds clipping
+
+      /*if (box_crap.left < 0) box_crap.left = 0; if (box_crap.top < box_real.top) box_crap.top = box_crap.top; if (box_crap.right > box_real.right) box_crap.right = box_real.right; if (box_crap.bottom > box_real.bottom) box_crap.bottom = box_real.bottom; */
     while (1)
       {
 // Msg("Box_crap: %d %d %d %d, Box_real: %d %d %d %d",box_crap.left,box_crap.top,
@@ -6433,9 +7125,9 @@
 	    Msg ("MainSpriteDraw(): Could not draw sprite %d, pic %d.", h,
 		 getpic (h));
 	    Msg ("Box_crap: %d %d %d %d, Box_real: %d %d %d %d",
-		 box_crap.left, box_crap.top, box_crap.right, box_crap.bottom,
-		 box_real.left, box_real.top, box_real.right,
-		 box_real.bottom);
+		   box_crap.left, box_crap.top, box_crap.right,
+		   box_crap.bottom, box_real.left, box_real.top,
+		   box_real.right, box_real.bottom);
 	    if (spr[h].pseq != 0)
 	      check_seq_status (spr[h].pseq);
 	    break;
@@ -6446,6 +7138,7 @@
 	  }
       }
 }
+}
 
 void
 changedir (int dir1, int k, int base)
@@ -6683,6 +7376,9 @@
     }
   if (*pexper != fexp)
     {
+      if ((talk.active == false && item_screen == false && spr[1].freeze == 0)
+	  || fexp + 10 < fraise)
+	{
 //update screen experience
 
       fexp += 10;
@@ -6701,6 +7397,7 @@
 	    run_script (script);
 	}
     }
+    }
   if (drawexp)
     {
       draw_exp ();
@@ -6776,7 +7473,12 @@
   if (*pmagic_cost > 0)
     if (*pmagic_level > 0)
       {
-	int mnum = *pmagic_level / (*pmagic_cost / 100);
+	double mnumd = *pmagic_level;
+	mnumd *= 100;
+	mnumd /= *pmagic_cost;
+	int mnum = static_cast < int >(mnumd);
+//int mnum = *pmagic_level / (*pmagic_cost / 100);
+
 	if (mnum != last_magic_draw)
 	  {
 	    draw_mlevel (mnum);
@@ -6804,6 +7506,7 @@
   int highest_sprite;
   update_play_changes ();
   memset (&bs, 0, sizeof (bs));
+  memset (&rank, 0, sizeof (rank));
   int hs;
   for (int r1 = 1; r1 < 100; r1++)
     {
@@ -7317,11 +8020,23 @@
 void
 random_blood (int mx, int my, int h)
 {
+//if ((rand() % 2) == 1) myseq = 188; else myseq = 187;
+
+//redink1 - customizable blood depending on what sprite we hit!!
+
   int myseq;
-  if ((rand () % 2) == 1)
-    myseq = 188;
+  int randy;
+  if (spr[h].bloodseq > 0 && spr[h].bloodnum > 0)
+    {
+      myseq = spr[h].bloodseq;
+      randy = spr[h].bloodnum;
+    }
   else
+    {
     myseq = 187;
+      randy = 3;
+    }
+  myseq += (rand () % randy);
   int crap2 = add_sprite (mx, my, 5, myseq, 1);
   spr[crap2].speed = 0;
   spr[crap2].base_walk = -1;
@@ -7669,6 +8384,16 @@
   DDBLTFX ddbltfx;
   ZeroMemory (&ddbltfx, sizeof (ddbltfx));
   ddbltfx.dwSize = sizeof (ddbltfx);
+//redink1 fix for correct fill_screen colors in truecolor mode
+
+  if (truecolor)
+    {
+      lpDDPal->GetEntries (0, 0, 256, pe);
+      ddbltfx.dwFillColor =
+	pe[num].peBlue << wBPos | pe[num].peGreen << wGPos | pe[num].
+	peRed << wRPos;
+    }
+  else
   ddbltfx.dwFillColor = num;
   crap =
     lpDDSTwo->Blt (NULL, NULL, NULL, DDBLT_COLORFILL | DDBLT_WAIT, &ddbltfx);
@@ -7796,6 +8521,7 @@
 
   if (ev[1][strlen (ev[1]) - 1] == ':')
     if (strlen (ev[2]) < 2)
+      if (strncmp (ev[1], "say", 3) != 0)
       {
 // Msg("Found label %s..",ev[1]); 
 
@@ -7820,6 +8546,8 @@
 
 //Msg("We found %s, woah!", temp);
 
+//These are used for conditionals??
+
       if (strchr (temp, '=') != NULL)
 	{
 	  h = &h[1];
@@ -8019,148 +8747,687 @@
 	strcpy (s, h);
 	return (1);
       }
-    if (compare (ev[1], "unfreeze"))
+    if (compare (ev[1], "show_console"))
       {
 	h = &h[strlen (ev[1])];
-	int p[20] = { 1, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
-	if (get_parms (ev[1], script, h, p))
-	  {
-//Msg("UnFreeze called for %d.", nlist[0]);
-
-	    if (spr[nlist[0]].active)
-	      spr[nlist[0]].freeze = 0;
-	    else
-	      Msg
-		("Couldn't unfreeze sprite %d in script %d, it doesn't exist.",
-		 nlist[0], script);
-	  }
-	strcpy (s, h);
-	return (0);
+	mConsoleActive = true;	/*int p[20] = {1,0,0,0,0,0,0,0,0,0}; if (get_parms(ev[1], script, h, p)) { if ( nlist[0] >= 1 ) { mConsoleActive = true; } else { mConsoleActive = false; } } returnint = 0; if ( mConsoleActive ) { returnint = 1; } */
       }
-    if (compare (ev[1], "freeze"))
-      {
-//Msg("Freeze called (%s)", h); 
+//redink1 - sets font color
 
-	h = &h[strlen (ev[1])];
-	int p[20] = { 1, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
-	if (get_parms (ev[1], script, h, p))
-	  {
-	    if (spr[nlist[0]].active)
-	      spr[nlist[0]].freeze = script;
-	    else
-	      Msg
-		("Couldn't freeze sprite %d in script %d, it doesn't exist.",
-		 nlist[0], script);
-	  }
-	strcpy (s, h);
-	return (0);
-      }
-    if (compare (ev[1], "set_callback_random"))
+    if (compare (ev[1], "set_font_color"))
       {
-	Msg ("setting callback random");
 	h = &h[strlen (ev[1])];
-	int p[20] = { 2, 1, 1, 0, 0, 0, 0, 0, 0, 0 };
+	int p[20] = { 1, 1, 1, 1, 0, 0, 0, 0, 0, 0 };
 	if (get_parms (ev[1], script, h, p))
 	  {
-	    int cb = add_callback (slist[0], nlist[1], nlist[2], script);
-//got all parms, let do it
-
+	    if (nlist[0] >= 1 && nlist[0] <= 15 && nlist[1] >= 0
+		&& nlist[1] <= 255 && nlist[2] >= 0 && nlist[2] <= 255
+		&& nlist[3] >= 0 && nlist[3] <= 255)
+	      {
+		font_colors[nlist[0]].red = nlist[1];
+		font_colors[nlist[0]].green = nlist[2];
+		font_colors[nlist[0]].blue = nlist[3];
+	      }
 	  }
 	strcpy (s, h);
 	return (0);
       }
-    if (compare (ev[1], "set_dink_speed"))
+//redink1 - clears the editor information, useful for save games and such
+
+    if (compare (ev[1], "clear_editor_info"))
       {
-	Msg ("setting callback random");
 	h = &h[strlen (ev[1])];
-	int p[20] = { 1, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
-	if (get_parms (ev[1], script, h, p))
+	for (int i = 0; i < 769; i++)
 	  {
-	    dinkspeed = nlist[0];
-	  }
-	strcpy (s, h);
+	    for (int j = 0; j < 100; j++)
+	      {
+		play.spmap[i].seq[j] = 0;
+		play.spmap[i].frame[j] = 0;
+		play.spmap[i].type[j] = 0;
+		play.spmap[i].last_time = 0;
+	  }} returnint = 1;
 	return (0);
       }
-    if (compare (ev[1], "reset_timer"))
+//redink1 - returns the number of variables used
+
+    if (compare (ev[1], "var_used"))
       {
 	h = &h[strlen (ev[1])];
-	time (&time_start);
-	play.minutes = 0;
-	strcpy (s, h);
+	int m = 0;
+	for (int i = 1; i < max_vars; i++)
+	  if (play.var[i].active == true)
+	    m++;
+	returnint = m;
 	return (0);
       }
-    if (compare (ev[1], "set_keep_mouse"))
+//redink1 added this function to load a new map/dink.dat
+
+    if (compare (ev[1], "load_map"))
       {
-	Msg ("setting callback random");
 	h = &h[strlen (ev[1])];
-	int p[20] = { 1, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
+	int p[20] = { 2, 2, 0, 0, 0, 0, 0, 0, 0, 0 };
 	if (get_parms (ev[1], script, h, p))
 	  {
-	    keep_mouse = nlist[0];
+	    strcpy (current_map, slist[0]);
+	    strcpy (current_dat, slist[1]);
+	    load_info ();
 	  }
 	strcpy (s, h);
 	return (0);
       }
-    if (compare (ev[1], "add_item"))
+//redink1 added this function to load a pallete from any bmp
+
+    if (compare (ev[1], "load_palette"))
       {
 	h = &h[strlen (ev[1])];
-	int p[20] = { 2, 1, 1, 0, 0, 0, 0, 0, 0, 0 };
+	int p[20] = { 2, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
 	if (get_parms (ev[1], script, h, p))
 	  {
-	    add_item (slist[0], nlist[1], nlist[2], false);
+	    if (exist (slist[0]))
+	      {
+		LPDIRECTDRAWSURFACE oldTrick =
+		  DDLoadBitmap (lpDD, slist[0], 0, 0);
+		lpDDPal = DDLoadPalette (lpDD, slist[0]);
+		if (lpDDPal)
+		  {
+		    lpDDSPrimary->SetPalette (lpDDPal);
+		    lpDDPal->GetEntries (0, 0, 256, pe);
+		    lpDDPal->GetEntries (0, 0, 256, real_pal);
+//Store in save game
+
+		    strncpy (play.palette, slist[0], 50);
+		  }
+		oldTrick->Release ();
+	      }
 	  }
 	strcpy (s, h);
 	return (0);
       }
-    if (compare (ev[1], "add_exp"))
+//redink1 added this function to load new tiles, because he is a l33t guy
+
+    if (compare (ev[1], "load_tile"))
       {
 	h = &h[strlen (ev[1])];
-	int p[20] = { 1, 1, 0, 0, 0, 0, 0, 0, 0, 0 };
+	int p[20] = { 2, 1, 0, 0, 0, 0, 0, 0, 0, 0 };
 	if (get_parms (ev[1], script, h, p))
 	  {
-	    add_exp (nlist[0], nlist[1]);
+	    if (!exist (slist[0]))
+	      {
+		sprintf (slist[0], "..\\DINK\\%s", slist[0]);
+	      }
+	    if (exist (slist[0]) && nlist[1] > 0 && nlist[1] < tile_screens)
+	      {
+//Need to unload old tiles...
+
+		tiles[nlist[1]]->Release ();
+//Load in the new tiles...
+
+		tiles[nlist[1]] = DDTileLoad (lpDD, slist[0], 0, 0, nlist[1]);
+		DDSetColorKey (tiles[nlist[1]], RGB (0, 0, 0));
+//Store in save game
+
+		strncpy (play.tile[nlist[1]].file, slist[0], 50);
+	      }
 	  }
 	strcpy (s, h);
 	return (0);
       }
-    if (compare (ev[1], "add_magic"))
+//redink1 added this function to change the save game 'info'
+
+    if (compare (ev[1], "set_save_game_info"))
       {
 	h = &h[strlen (ev[1])];
-	int p[20] = { 2, 1, 1, 0, 0, 0, 0, 0, 0, 0 };
+	int p[20] = { 2, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
 	if (get_parms (ev[1], script, h, p))
 	  {
-	    add_item (slist[0], nlist[1], nlist[2], true);
+	    strcpy (save_game_info, slist[0]);
 	  }
 	strcpy (s, h);
 	return (0);
       }
-    if (compare (ev[1], "kill_this_item"))
+//redink1 added this function to show the item screen
+
+    if (compare (ev[1], "show_inventory"))
       {
 	h = &h[strlen (ev[1])];
-	int p[20] = { 2, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
-	if (get_parms (ev[1], script, h, p))
-	  {
-	    kill_cur_item_script (slist[0]);
-	  }
+	item_screen = true;
 	strcpy (s, h);
 	return (0);
       }
-    if (compare (ev[1], "kill_this_magic"))
+//redink1 added this function,, and took it away.
+
+    /*if (compare(ev[1], "get_compatibility")) { returnint = 0; h = &h[strlen(ev[1])]; int p[20] = {2,1,0,0,0,0,0,0,0,0}; if (get_parms(ev[1], script, h, p)) { if (compare(slist[0],"get_compatibility")) { if (nlist[1] <= 1) { returnint = 1; } } } strcpy(s, h); return(0); } */
+//redink1 added this function
+
+    if (compare (ev[1], "get_time_game"))
       {
 	h = &h[strlen (ev[1])];
-	int p[20] = { 2, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
-	if (get_parms (ev[1], script, h, p))
-	  {
-	    kill_cur_magic_script (slist[0]);
-	  }
+	time_t ct;
+	time (&ct);
+	returnint = play.minutes + (difftime (ct, time_start) / 60);
 	strcpy (s, h);
 	return (0);
       }
-    if (compare (ev[1], "show_bmp"))
+//redink1 added this function
+
+    if (compare (ev[1], "get_time_real"))
       {
-	Msg ("showing BMP");
 	h = &h[strlen (ev[1])];
-	int p[20] = { 2, 1, 1, 0, 0, 0, 0, 0, 0, 0 };
+	char mytime[5];
+	time_t ct;
+	struct tm *time_now;
+	time (&ct);
+	time_now = localtime (&ct);
+	strftime (mytime, 5, "%M", time_now);
+	returnint = atoi (mytime);
+	strftime (mytime, 5, "%H", time_now);
+	returnint += 60 * atoi (mytime);
+	strcpy (s, h);
+	return (0);
+      }
+//redink1 added this function
+
+    if (compare (ev[1], "get_date_year"))
+      {
+	h = &h[strlen (ev[1])];
+	char mytime[5];
+	time_t ct;
+	struct tm *time_now;
+	time (&ct);
+	time_now = localtime (&ct);
+	strftime (mytime, 5, "%Y", time_now);
+	returnint = atoi (mytime);
+	strcpy (s, h);
+	return (0);
+      }
+//redink1 added this function
+
+    if (compare (ev[1], "get_date_month"))
+      {
+	h = &h[strlen (ev[1])];
+	char mytime[5];
+	time_t ct;
+	struct tm *time_now;
+	time (&ct);
+	time_now = localtime (&ct);
+	strftime (mytime, 5, "%m", time_now);
+	returnint = atoi (mytime);
+	strcpy (s, h);
+	return (0);
+      }
+//redink1 added this function
+
+    if (compare (ev[1], "get_date_day"))
+      {
+	h = &h[strlen (ev[1])];
+	char mytime[5];
+	time_t ct;
+	struct tm *time_now;
+	time (&ct);
+	time_now = localtime (&ct);
+	strftime (mytime, 5, "%d", time_now);
+	returnint = atoi (mytime);
+	strcpy (s, h);
+	return (0);
+      }
+//redink1 added this function
+
+    if (compare (ev[1], "math_abs"))
+      {
+	h = &h[strlen (ev[1])];
+	int p[20] = { 1, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
+	if (get_parms (ev[1], script, h, p))
+	  {
+	    returnint = abs (nlist[0]);
+	  }
+	strcpy (s, h);
+	return (0);
+      }
+//redink1 added this function
+
+    /*if (compare(ev[1], "math_sin")) { h = &h[strlen(ev[1])]; int p[20] = {1,0,0,0,0,0,0,0,0,0}; if (get_parms(ev[1], script, h, p)) { returnint = sin((double)nlist[0]); } strcpy(s, h); return(0); } 
+       //redink1 added this function
+
+       if (compare(ev[1], "math_cos")) { h = &h[strlen(ev[1])]; int p[20] = {1,0,0,0,0,0,0,0,0,0}; if (get_parms(ev[1], script, h, p)) { returnint = cos((double)nlist[0]); } strcpy(s, h); return(0); } 
+       //redink1 added this function
+
+       if (compare(ev[1], "math_tan")) { h = &h[strlen(ev[1])]; int p[20] = {1,0,0,0,0,0,0,0,0,0}; if (get_parms(ev[1], script, h, p)) { returnint = tan((double)nlist[0]); } strcpy(s, h); return(0); } */
+//redink1 added this function
+
+    if (compare (ev[1], "math_sqrt"))
+      {
+	h = &h[strlen (ev[1])];
+	int p[20] = { 1, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
+	if (get_parms (ev[1], script, h, p))
+	  {
+	    returnint = sqrt ((double) abs (nlist[0]));
+	  }
+	strcpy (s, h);
+	return (0);
+      }
+//redink1 added this function
+
+    if (compare (ev[1], "math_mod"))
+      {
+	h = &h[strlen (ev[1])];
+	int p[20] = { 1, 1, 0, 0, 0, 0, 0, 0, 0, 0 };
+	if (get_parms (ev[1], script, h, p))
+	  {
+	    returnint = (nlist[0] % nlist[1]);
+	  }
+	strcpy (s, h);
+	return (0);
+      }
+//redink1
+
+    if (compare (ev[1], "sp_custom"))
+      {
+	h = &h[strlen (ev[1])];
+	int p[20] = { 2, 1, 1, 0, 0, 0, 0, 0, 0, 0 };
+	if (get_parms (ev[1], script, h, p) && spr[nlist[1]].active == TRUE)
+	  {
+	    if (nlist[1] < 1 || spr[nlist[1]].active == false)
+	      {
+		returnint = -1;
+	      }
+	    else
+	      {
+// If key doesn't exist, create it.
+
+		if (spr[nlist[1]].custom->find (slist[0]) ==
+		    spr[nlist[1]].custom->end ())
+		  {
+// spr[nlist[1]].custom->insert( std::make_pair( slist[0], 0 ) );
+
+		  }
+// Set the value
+
+		if (nlist[2] != -1)
+		  {
+		    spr[nlist[1]].custom->erase (slist[0]);
+// spr[nlist[1]].custom->insert( std::make_pair( slist[0], nlist[2] ) );
+
+		  }
+		returnint = spr[nlist[1]].custom->find (slist[0])->second;
+	      }
+	    return (0);
+	  }
+	returnint = -1;
+	return (0);
+      }
+//redink1
+
+    if (compare (ev[1], "sp_blood_seq"))
+      {
+	h = &h[strlen (ev[1])];
+	int p[20] = { 1, 1, 0, 0, 0, 0, 0, 0, 0, 0 };
+	if (get_parms (ev[1], script, h, p))
+	  {
+	    change_sprite (nlist[0], nlist[1], &spr[nlist[0]].bloodseq);
+	    returnint = spr[nlist[0]].bloodseq;
+	    return (0);
+	  }
+	returnint = -1;
+	return (0);
+      }
+//redink1
+
+    if (compare (ev[1], "sp_blood_num"))
+      {
+	h = &h[strlen (ev[1])];
+	int p[20] = { 1, 1, 0, 0, 0, 0, 0, 0, 0, 0 };
+	if (get_parms (ev[1], script, h, p))
+	  {
+	    change_sprite (nlist[0], nlist[1], &spr[nlist[0]].bloodnum);
+	    returnint = spr[nlist[0]].bloodseq;
+	    return (0);
+	  }
+	returnint = -1;
+	return (0);
+      }
+//redink1 added to get index of specified item
+
+    if (compare (ev[1], "get_item"))
+      {
+	h = &h[strlen (ev[1])];
+	int p[20] = { 2, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
+	if (get_parms (ev[1], script, h, p))
+	  {
+	    returnint = 0;
+	    for (int i = 1; i < 17; i++)
+	      {
+		if (play.item[i].active)
+		  {
+		    if (compare (play.item[i].name, slist[0]))
+		      {
+			returnint = i;
+			break;
+		      }
+		  }
+	      }
+	    return (0);
+	  }
+	returnint = -1;
+	return (0);
+      }
+//redink1 added to get index of specified magic spell
+
+    if (compare (ev[1], "get_magic"))
+      {
+	h = &h[strlen (ev[1])];
+	int p[20] = { 2, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
+	if (get_parms (ev[1], script, h, p))
+	  {
+	    returnint = 0;
+	    for (int i = 1; i < 9; i++)
+	      {
+		if (play.mitem[i].active)
+		  {
+		    if (compare (play.mitem[i].name, slist[0]))
+		      {
+			returnint = i;
+			break;
+		      }
+		  }
+	      }
+	    return (0);
+	  }
+	returnint = -1;
+	return (0);
+      }
+//redink1 clip stuff
+
+    if (compare (ev[1], "sp_clip_left"))
+      {
+	h = &h[strlen (ev[1])];
+	int p[20] = { 1, 1, 0, 0, 0, 0, 0, 0, 0, 0 };
+	if (get_parms (ev[1], script, h, p))
+	  {
+	    change_sprite (nlist[0], nlist[1], &spr[nlist[0]].alt.left);
+	    returnint = spr[nlist[0]].alt.left;
+	    return (0);
+	  }
+	returnint = -1;
+	return (0);
+      }
+//redink1 clip stuff
+
+    if (compare (ev[1], "sp_clip_top"))
+      {
+	h = &h[strlen (ev[1])];
+	int p[20] = { 1, 1, 0, 0, 0, 0, 0, 0, 0, 0 };
+	if (get_parms (ev[1], script, h, p))
+	  {
+	    change_sprite (nlist[0], nlist[1], &spr[nlist[0]].alt.top);
+	    returnint = spr[nlist[0]].alt.top;
+	    return (0);
+	  }
+	returnint = -1;
+	return (0);
+      }
+//redink1 clip stuff
+
+    if (compare (ev[1], "sp_clip_right"))
+      {
+	h = &h[strlen (ev[1])];
+	int p[20] = { 1, 1, 0, 0, 0, 0, 0, 0, 0, 0 };
+	if (get_parms (ev[1], script, h, p))
+	  {
+	    change_sprite (nlist[0], nlist[1], &spr[nlist[0]].alt.right);
+	    returnint = spr[nlist[0]].alt.right;
+	    return (0);
+	  }
+	returnint = -1;
+	return (0);
+      }
+//redink1 clip stuff
+
+    if (compare (ev[1], "sp_clip_bottom"))
+      {
+	h = &h[strlen (ev[1])];
+	int p[20] = { 1, 1, 0, 0, 0, 0, 0, 0, 0, 0 };
+	if (get_parms (ev[1], script, h, p))
+	  {
+	    change_sprite (nlist[0], nlist[1], &spr[nlist[0]].alt.bottom);
+	    returnint = spr[nlist[0]].alt.bottom;
+	    return (0);
+	  }
+	returnint = -1;
+	return (0);
+      }
+//redink1 added so users can check truecolor or not
+
+    if (compare (ev[1], "get_truecolor"))
+      {
+	h = &h[strlen (ev[1])];
+	returnint = truecolor;
+	strcpy (s, h);
+	return (0);
+      }
+//redink1 added so developers can change or see what tile is at any given position
+
+    if (compare (ev[1], "map_tile"))
+      {
+	h = &h[strlen (ev[1])];
+	int p[20] = { 1, 1, 0, 0, 0, 0, 0, 0, 0, 0 };
+	if (get_parms (ev[1], script, h, p))
+	  {
+//Yeah... they can only modify valid tiles
+
+	    if (nlist[0] > 0 && nlist[0] <= 96)
+	      {
+//Only change the value if it is greater than 0...
+
+		if (nlist[1] > 0)
+		  {
+		    pam.t[nlist[0] - 1].num = nlist[1];
+		  }
+		returnint = pam.t[nlist[0] - 1].num;
+		return (0);
+	      }
+	  }
+	returnint = -1;
+	return (0);
+      }
+//redink1 added so a developer can retrieve/modify a hard tile
+
+    if (compare (ev[1], "map_hard_tile"))
+      {
+	h = &h[strlen (ev[1])];
+	int p[20] = { 1, 1, 0, 0, 0, 0, 0, 0, 0, 0 };
+	if (get_parms (ev[1], script, h, p))
+	  {
+//Yeah... they can only modify valid tiles
+
+	    if (nlist[0] > 0 && nlist[0] <= 96)
+	      {
+//Only change the value if it is greater than 0...
+
+		if (nlist[1] > 0)
+		  {
+		    pam.t[nlist[0] - 1].althard = nlist[1];
+		  }
+		returnint = pam.t[nlist[0] - 1].althard;
+		return (0);
+	      }
+	  }
+	returnint = -1;
+	return (0);
+      }
+    if (compare (ev[1], "unfreeze"))
+      {
+	h = &h[strlen (ev[1])];
+	int p[20] = { 1, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
+	if (get_parms (ev[1], script, h, p))
+	  {
+//Msg("UnFreeze called for %d.", nlist[0]);
+
+	    if (spr[nlist[0]].active)
+	      spr[nlist[0]].freeze = 0;
+	    else
+	      Msg
+		("Couldn't unfreeze sprite %d in script %d, it doesn't exist.",
+		 nlist[0], script);
+	  }
+	strcpy (s, h);
+	return (0);
+      }
+    if (compare (ev[1], "freeze"))
+      {
+//Msg("Freeze called (%s)", h); 
+
+	h = &h[strlen (ev[1])];
+	int p[20] = { 1, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
+	if (get_parms (ev[1], script, h, p))
+	  {
+	    if (spr[nlist[0]].active)
+	      spr[nlist[0]].freeze = script;
+	    else
+	      Msg
+		("Couldn't freeze sprite %d in script %d, it doesn't exist.",
+		 nlist[0], script);
+	  }
+	strcpy (s, h);
+	return (0);
+      }
+    if (compare (ev[1], "set_callback_random"))
+      {
+	Msg ("setting callback random");
+	h = &h[strlen (ev[1])];
+	int p[20] = { 2, 1, 1, 0, 0, 0, 0, 0, 0, 0 };
+	if (get_parms (ev[1], script, h, p))
+	  {
+	    int cb = add_callback (slist[0], nlist[1], nlist[2], script);
+//got all parms, let do it
+
+	    returnint = cb;
+	  }
+	strcpy (s, h);
+	return (0);
+      }
+// redink1 added
+
+    if (compare (ev[1], "callback_kill"))
+      {
+	Msg ("setting callback random");
+	h = &h[strlen (ev[1])];
+	int p[20] = { 1, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
+	if (get_parms (ev[1], script, h, p))
+	  {
+	    if (nlist[0] >= 0 && nlist[0] <= 99)
+	      {
+		callback[nlist[0]].active = false;
+	      }
+	  }
+	strcpy (s, h);
+	return (0);
+      }
+    if (compare (ev[1], "set_dink_speed"))
+      {
+	Msg ("setting callback random");
+	h = &h[strlen (ev[1])];
+	int p[20] = { 1, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
+	if (get_parms (ev[1], script, h, p) && nlist[0] != 0)
+	  {
+	    dinkspeed = nlist[0];
+	  }
+	strcpy (s, h);
+	return (0);
+      }
+//redink1
+
+    if (compare (ev[1], "set_dink_base_push"))
+      {
+	Msg ("setting callback random");
+	h = &h[strlen (ev[1])];
+	int p[20] = { 1, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
+	if (get_parms (ev[1], script, h, p))
+	  {
+	    mDinkBasePush = nlist[0];
+	  }
+	strcpy (s, h);
+	return (0);
+      }
+    if (compare (ev[1], "reset_timer"))
+      {
+	h = &h[strlen (ev[1])];
+	time (&time_start);
+	play.minutes = 0;
+	strcpy (s, h);
+	return (0);
+      }
+    if (compare (ev[1], "set_keep_mouse"))
+      {
+	Msg ("setting callback random");
+	h = &h[strlen (ev[1])];
+	int p[20] = { 1, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
+	if (get_parms (ev[1], script, h, p))
+	  {
+	    keep_mouse = nlist[0];
+	  }
+	strcpy (s, h);
+	return (0);
+      }
+    if (compare (ev[1], "add_item"))
+      {
+	h = &h[strlen (ev[1])];
+	int p[20] = { 2, 1, 1, 0, 0, 0, 0, 0, 0, 0 };
+	if (get_parms (ev[1], script, h, p))
+	  {
+	    add_item (slist[0], nlist[1], nlist[2], false);
+	  }
+	strcpy (s, h);
+	return (0);
+      }
+    if (compare (ev[1], "add_exp"))
+      {
+	h = &h[strlen (ev[1])];
+	int p[20] = { 1, 1, 0, 0, 0, 0, 0, 0, 0, 0 };
+	if (get_parms (ev[1], script, h, p))
+	  {
+	    add_exp (nlist[0], nlist[1], true);
+	  }
+	strcpy (s, h);
+	return (0);
+      }
+    if (compare (ev[1], "add_magic"))
+      {
+	h = &h[strlen (ev[1])];
+	int p[20] = { 2, 1, 1, 0, 0, 0, 0, 0, 0, 0 };
+	if (get_parms (ev[1], script, h, p))
+	  {
+	    add_item (slist[0], nlist[1], nlist[2], true);
+	  }
+	strcpy (s, h);
+	return (0);
+      }
+    if (compare (ev[1], "kill_this_item"))
+      {
+	h = &h[strlen (ev[1])];
+	int p[20] = { 2, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
+	if (get_parms (ev[1], script, h, p))
+	  {
+	    kill_cur_item_script (slist[0]);
+	  }
+	strcpy (s, h);
+	return (0);
+      }
+    if (compare (ev[1], "kill_this_magic"))
+      {
+	h = &h[strlen (ev[1])];
+	int p[20] = { 2, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
+	if (get_parms (ev[1], script, h, p))
+	  {
+	    kill_cur_magic_script (slist[0]);
+	  }
+	strcpy (s, h);
+	return (0);
+      }
+    if (compare (ev[1], "show_bmp"))
+      {
+	Msg ("showing BMP");
+	h = &h[strlen (ev[1])];
+	int p[20] = { 2, 1, 1, 0, 0, 0, 0, 0, 0, 0 };
 	if (get_parms (ev[1], script, h, p))
 	  {
 	    wait.active = false;
@@ -8297,6 +9564,10 @@
 
 	update_screen_time ();
 	load_map (map.loc[*pmap]);
+//redink1 fix for correct indicator on mini-map
+
+	if (map.indoor[*pmap] == 0)
+	  play.last_map = *pmap;
 	return (0);
       }
     if (compare (ev[1], "choice_start"))
@@ -8552,9 +9824,11 @@
 	int p[20] = { 1, 2, 0, 0, 0, 0, 0, 0, 0 };
 	if (get_parms (ev[1], script, h, p))
 	  {
-	    locate (nlist[0], slist[1]);
+	    if (locate (nlist[0], slist[1]))
+	      {
 	    run_script (nlist[0]);
 	  }
+	  }
 	strcpy (s, h);
 	return (0);
       }
@@ -8585,6 +9859,7 @@
 	process_downcycle = true;
 	cycle_clock = thisTickCount + 1000;
 	cycle_script = script;
+	strcpy (s, h);
 	return (2);
       }
     if (compare (ev[1], "fade_up"))
@@ -8641,8 +9908,24 @@
 	  }
 //InitSound(hWndMain);
 
-	strcpy (s, h);
-	return (2);
+				   strcpy(s, h); return(2); } */
+//redink1 added
+
+    if (compare (ev[1], "loopmidi"))
+      {
+	h = &h[strlen (ev[1])];
+	int p[20] = { 1, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
+	if (get_parms (ev[1], script, h, p))
+	  {
+	    if (nlist[0] > 0)
+	      {
+		mLoopMidi = true;
+	      }
+	    else
+	      {
+		mLoopMidi = false;
+	      }
+	  }
       }
     if (compare (ev[1], "playmidi"))
       {
@@ -8926,6 +10209,21 @@
 	locate_goto (ev[2], script);
 	return (0);
       }
+//redink1 added for global functions
+
+    if (compare (ev[1], "make_global_function"))
+      {
+	h = &h[strlen (ev[1])];
+	int p[20] = { 2, 2, 0, 0, 0, 0, 0, 0, 0, 0 };
+	if (get_parms (ev[1], script, h, p))
+	  {
+	    make_function (slist[0], slist[1]);
+//Msg(slist[0]);
+
+	  }
+	strcpy (s, h);
+	return (0);
+      }
     if (compare (ev[1], "make_global_int"))
       {
 	h = &h[strlen (ev[1])];
@@ -9210,6 +10542,29 @@
 	returnint = 0;
 	return (0);
       }
+//redink1 added this to make Paul Pliska's life more fulfilling
+
+    if (compare (ev[1], "get_next_sprite_with_this_brain"))
+      {
+	h = &h[strlen (ev[1])];
+	int p[20] = { 1, 1, 1, 0, 0, 0, 0, 0, 0, 0 };
+	if (get_parms (ev[1], script, h, p))
+	  {
+	    for (int i = nlist[2]; i <= last_sprite_created; i++)
+	      {
+		if ((spr[i].brain == nlist[0]) && (i != nlist[1]))
+		  if (spr[i].active == 1)
+		    {
+		      Msg ("Ok, sprite with brain %d is %d", nlist[0], i);
+		      returnint = i;
+		      return (0);
+		    }
+	      }
+	  }
+	Msg ("Ok, sprite with brain %d is 0", nlist[0], i);
+	returnint = 0;
+	return (0);
+      }
     if (compare (ev[1], "get_rand_sprite_with_this_brain"))
       {
 	h = &h[strlen (ev[1])];
@@ -9259,7 +10614,7 @@
 	  {
 	    returnint =
 	      change_sprite (nlist[0], nlist[1], &spr[nlist[0]].sound);
-	    if (nlist[1] != 0)
+	    if (nlist[1] > 0)
 	      {
 		SoundPlayEffect (spr[nlist[0]].sound, 22050, 0, nlist[0], 1);
 	      }
@@ -9680,6 +11035,25 @@
 	returnint = -1;
 	return (0);
       }
+    if (compare (ev[1], "set_smooth_follow"))
+      {
+	h = &h[strlen (ev[1])];
+	int p[20] = { 1, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
+	if (get_parms (ev[1], script, h, p))
+	  {
+	    if (nlist[0] == 0)
+	      {
+		smooth_follow = false;
+	      }
+	    else if (nlist[0] == 1)
+	      {
+		smooth_follow = true;
+	      }
+	    return (0);
+	  }
+	returnint = -1;
+	return (0);
+      }
     if (compare (ev[1], "sp_frame"))
       {
 	h = &h[strlen (ev[1])];
@@ -9712,6 +11086,10 @@
 	int p[20] = { 1, 1, 0, 0, 0, 0, 0, 0, 0, 0 };
 	if (get_parms (ev[1], script, h, p))
 	  {
+//redink1 fix for freeze if hurt value is less than 0
+
+	    if (nlist[1] < 0)
+	      return (0);
 	    if (hurt_thing (nlist[0], nlist[1], 0) > 0)
 	      random_blood (spr[nlist[0]].x, spr[nlist[0]].y - 40, nlist[0]);
 	    if (spr[nlist[0]].nohit != 1)
@@ -9719,7 +11097,12 @@
 		if (locate (spr[nlist[0]].script, "HIT"))
 		  {
 		    if (rinfo[script]->sprite != 1000)
+		      {
 		      *penemy_sprite = rinfo[script]->sprite;
+//redink1 addition of missle_source stuff
+
+			*pmissle_source = rinfo[script]->sprite;
+		      }
 		    kill_returning_stuff (spr[nlist[0]].script);
 		    run_script (spr[nlist[0]].script);
 		  }
@@ -9802,10 +11185,14 @@
 	int p[20] = { 1, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
 	if (get_parms (ev[1], script, h, p))
 	  {
+	    if (nlist[0] == 0 || nlist[0] == 1)
+	      {
 	    screenlock = nlist[0];
-	    return (0);
 	  }
-	returnint = -1;
+	  }
+//redink1 - set screenlock() to return the screenlock value
+
+	returnint = screenlock;
 	return (0);
       }
     if (compare (ev[1], "stop_entire_game"))
@@ -9925,6 +11312,17 @@
 	returnint = -1;
 	return (0);
       }
+    if (compare (ev[1], "sp_move_x"))
+      {
+	h = &h[strlen (ev[1])];
+	int p[20] = { 1, 1, 0, 0, 0, 0, 0, 0, 0, 0 };
+	if (get_parms (ev[1], script, h, p))
+	  {
+	    change_sprite_noreturn (nlist[0], nlist[1], &spr[nlist[0]].mx);
+	    return (0);
+	  }
+	return (0);
+      }
     if (compare (ev[1], "sp_my"))
       {
 	h = &h[strlen (ev[1])];
@@ -9937,6 +11335,17 @@
 	returnint = -1;
 	return (0);
       }
+    if (compare (ev[1], "sp_move_y"))
+      {
+	h = &h[strlen (ev[1])];
+	int p[20] = { 1, 1, 0, 0, 0, 0, 0, 0, 0, 0 };
+	if (get_parms (ev[1], script, h, p))
+	  {
+	    change_sprite_noreturn (nlist[0], nlist[1], &spr[nlist[0]].my);
+	    return (0);
+	  }
+	return (0);
+      }
     if (compare (ev[1], "scripts_used"))
       {
 	h = &h[strlen (ev[1])];
@@ -10111,7 +11520,9 @@
 	      {
 		return (0);
 	      }
-	    if (compare (play.item[*pcur_magic].name, slist[0]))
+//redink1 fix so compare_magic works!
+
+	    if (compare (play.mitem[*pcur_magic].name, slist[0]))
 	      {
 		returnint = 1;
 	      }
@@ -10185,6 +11596,24 @@
 	  Msg ("Found return; statement");
 	if (rinfo[script]->proc_return != 0)
 	  {
+	    bKeepReturnInt = true;
+	    run_script (rinfo[script]->proc_return);
+	    kill_script (script);
+	  }
+	return (2);
+      }
+//redink1 added so we can have return values and crap.
+
+    if (compare (ev[1], "return"))
+      {
+	if (debug_mode)
+	  Msg ("Found return; statement");
+	h = &h[strlen (ev[1])];
+	strip_beginning_spaces (h);
+	process_line (script, h, false);
+	if (rinfo[script]->proc_return != 0)
+	  {
+	    bKeepReturnInt = true;
 	    run_script (rinfo[script]->proc_return);
 	    kill_script (script);
 	  }
@@ -10259,7 +11688,7 @@
 	strcpy (s, h);
 	return (0);
       }
-    if (compare (ev[2], "/"))
+    if (compare (ev[2], "/") || compare (ev[2], "/="))
       {
 	h = &h[strlen (ev[1])];
 	strip_beginning_spaces (h);
@@ -10269,7 +11698,7 @@
 	strcpy (s, h);
 	return (0);
       }
-    if (compare (ev[2], "*"))
+    if (compare (ev[2], "*") || compare (ev[2], "*="))
       {
 	h = &h[strlen (ev[1])];
 	strip_beginning_spaces (h);
@@ -10282,8 +11711,10 @@
     if (compare (ev[1], "external"))
       {
 	h = &h[strlen (ev[1])];
-	int p[20] = { 2, 2, 0, 0, 0, 0, 0, 0, 0, 0 };
-	if (get_parms (ev[1], script, h, p))
+	int p[20] = { 2, 2, 1, 1, 1, 1, 1, 1, 1, 1 };
+	memset (slist, 0, 10 * 200);
+	get_parms (ev[1], script, h, p);
+	if (strlen (slist[0]) > 0 && strlen (slist[1]) > 0)
 	  {
 	    int myscript1 =
 	      load_script (slist[0], rinfo[script]->sprite, false);
@@ -10293,6 +11724,14 @@
 		     slist[1]);
 		return (0);
 	      }
+	    rinfo[myscript1]->arg1 = nlist[2];
+	    rinfo[myscript1]->arg2 = nlist[3];
+	    rinfo[myscript1]->arg3 = nlist[4];
+	    rinfo[myscript1]->arg4 = nlist[5];
+	    rinfo[myscript1]->arg5 = nlist[6];
+	    rinfo[myscript1]->arg6 = nlist[7];
+	    rinfo[myscript1]->arg7 = nlist[8];
+	    rinfo[myscript1]->arg8 = nlist[9];
 	    if (locate (myscript1, slist[1]))
 	      {
 		rinfo[myscript1]->proc_return = script;
@@ -10313,22 +11752,58 @@
       {
 //lets attempt to run a procedure
 
-	seperate_string (h, 1, '(', line);
 	int myscript =
 	  load_script (rinfo[script]->name, rinfo[script]->sprite, false);
-	if (locate (myscript, line))
-	  {
+	h = &h[strlen (ev[1])];
+	int p[20] = { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 };
+	get_parms (ev[1], script, h, p);
+	if (locate (myscript, ev[1]))
+	  {
+	    rinfo[myscript]->arg1 = nlist[0];
+	    rinfo[myscript]->arg2 = nlist[1];
+	    rinfo[myscript]->arg3 = nlist[2];
+	    rinfo[myscript]->arg4 = nlist[3];
+	    rinfo[myscript]->arg5 = nlist[4];
+	    rinfo[myscript]->arg6 = nlist[5];
+	    rinfo[myscript]->arg7 = nlist[6];
+	    rinfo[myscript]->arg8 = nlist[7];
+	    rinfo[myscript]->arg9 = nlist[8];
 	    rinfo[myscript]->proc_return = script;
 	    run_script (myscript);
 	    return (2);
 	  }
 	else
 	  {
+	    for (int i = 0; strlen (play.func[i].func) > 0 && i < 100; i++)
+	      {
+		if (compare (play.func[i].func, ev[1]))
+		  {
+		    myscript =
+		      load_script (play.func[i].file, rinfo[script]->sprite,
+				   false);
+		    rinfo[myscript]->arg1 = nlist[0];
+		    rinfo[myscript]->arg2 = nlist[1];
+		    rinfo[myscript]->arg3 = nlist[2];
+		    rinfo[myscript]->arg4 = nlist[3];
+		    rinfo[myscript]->arg5 = nlist[4];
+		    rinfo[myscript]->arg6 = nlist[5];
+		    rinfo[myscript]->arg7 = nlist[6];
+		    rinfo[myscript]->arg8 = nlist[7];
+		    rinfo[myscript]->arg9 = nlist[8];
+		    if (locate (myscript, ev[1]))
+		      {
+			rinfo[myscript]->proc_return = script;
+			run_script (myscript);
+			return (2);
+		      }
+		    break;
+		  }
+	      }
 	    Msg
 	      ("ERROR: Procedure void %s( void ); not found in script %s. (word 2 was %s) ",
 	       line, ev[2], rinfo[myscript]->name);
 	    kill_script (myscript);
-	  }
+	  }			/*seperate_string(h, 1,'(',line); int myscript = load_script(rinfo[script]->name, rinfo[script]->sprite, false); if (locate( myscript, line)) { rinfo[myscript]->proc_return = script; run_script(myscript); return(2); } else { Msg("ERROR: Procedure void %s( void ); not found in script %s. (word 2 was %s) ", line, ev[2], rinfo[myscript]->name); kill_script(myscript); } */
 	return (0);
       }
     Msg ("MERROR: \"%s\" unknown in %s, offset %d.", ev[1],
@@ -10351,7 +11826,14 @@
 {
   int result;
   char line[200];
+  if (bKeepReturnInt)
+    {
+      bKeepReturnInt = false;
+    }
+  else
+    {
   returnint = 0;
+    }
   returnstring[0] = 0;
   if (rinfo[script] != NULL)
     {
@@ -10531,9 +12013,8 @@
 {
   for (int k = 1; k < max_scripts; k++)
     {
-      if (rinfo[k] != NULL)
-	if (rinfo[k]->sprite != 0)
-	  if (spr[rinfo[k]->sprite].active)
+      if (rinfo[k] != NULL && rinfo[k]->sprite != 0 && rinfo[k]->sprite < 300
+	  && spr[rinfo[k]->sprite].active)
 	    {
 	      if (locate (k, "main"))
 		{
@@ -10545,4 +12026,86 @@
 	    }
     }
 }
+
+//redink1 added for font colors
+
+void
+init_font_colors (void)
+{
+//Light Magenta
+
+  font_colors[1].red = 255;
+  font_colors[1].green = 198;
+  font_colors[1].blue = 255;
+//Dark Green
+
+  font_colors[2].red = 131;
+  font_colors[2].green = 181;
+  font_colors[2].blue = 74;
+//Bold Cyan
+
+  font_colors[3].red = 99;
+  font_colors[3].green = 242;
+  font_colors[3].blue = 247;
+//Orange
+
+  font_colors[4].red = 255;
+  font_colors[4].green = 156;
+  font_colors[4].blue = 74;
+//Magenta
+
+  font_colors[5].red = 222;
+  font_colors[5].green = 173;
+  font_colors[5].blue = 255;
+//Brown Orange
+
+  font_colors[6].red = 244;
+  font_colors[6].green = 188;
+  font_colors[6].blue = 73;
+//Light Gray
+
+  font_colors[7].red = 173;
+  font_colors[7].green = 173;
+  font_colors[7].blue = 173;
+//Dark Gray
+
+  font_colors[8].red = 85;
+  font_colors[8].green = 85;
+  font_colors[8].blue = 85;
+//Sky Blue
+
+  font_colors[9].red = 148;
+  font_colors[9].green = 198;
+  font_colors[9].blue = 255;
+//Bright Green
+
+  font_colors[10].red = 0;
+  font_colors[10].green = 255;
+  font_colors[10].blue = 0;
+//Yellow
+
+  font_colors[11].red = 255;
+  font_colors[11].green = 255;
+  font_colors[11].blue = 2;
+//Yellow
+
+  font_colors[12].red = 255;
+  font_colors[12].green = 255;
+  font_colors[12].blue = 2;
+//Hot Pink
+
+  font_colors[13].red = 255;
+  font_colors[13].green = 132;
+  font_colors[13].blue = 132;
+//Yellow
+
+  font_colors[14].red = 255;
+  font_colors[14].green = 255;
+  font_colors[14].blue = 2;
+//White
+
+  font_colors[15].red = 255;
+  font_colors[15].green = 255;
+  font_colors[15].blue = 255;
+}
 #endif
